<blueprint>
  <file path="index.tsx">
    <![CDATA[
import React from 'react';
import ReactDOM from 'react-dom/client';
import { App } from './App';
import { ToastProvider } from './components/Toast';
import { initializeApp } from "firebase/app";

// This is a placeholder configuration.
// When the app is deployed to Firebase Hosting or run in Firebase Studio,
// the correct configuration is automatically injected by the environment.
// For local development outside of the Firebase environment, you would
// typically use the Firebase Emulator Suite or a local config file.
// This placeholder prevents the app from crashing on startup in such environments.
const firebaseConfig = {
  apiKey: "AIzaSy...",
  authDomain: "your-project-id.firebaseapp.com",
  projectId: "your-project-id",
  storageBucket: "your-project-id.appspot.com",
  messagingSenderId: "123456789012",
  appId: "1:123456789012:web:abcdef1234567890abcdef"
};

// Initialize Firebase.
// Using the config prevents the "no-options" error in local environments.
// The Firebase SDK is smart enough to use the auto-injected config when available,
// making this safe for deployment.
initializeApp(firebaseConfig);

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <ToastProvider>
      <App />
    </ToastProvider>
  </React.StrictMode>
);
]]>
  </file>
  <file path="metadata.json">
    <![CDATA[
{
  "name": "Zenith Engine AI",
  "description": "An AI-powered application to generate and publish fully SEO-optimized blog posts directly to your WordPress site. Simply provide a topic, and let the AI handle keyword research, content creation, and image generation.",
  "requestFramePermissions": [
    "camera",
    "microphone"
  ]
}
]]>
  </file>
  <file path="index.html">
    <![CDATA[
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-900">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zenith Engine AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://js.paystack.co/v1/inline.js"></script>
    <style>
      :root {
        --color-background: #0a0a0f;
        --color-panel: #1e1e29;
        --color-panel-light: #2a2a3a;
        --color-border: #404050;
        --color-border-subtle: #2a2a3a;
        --color-text-primary: #f0f0f5;
        --color-text-secondary: #a0a0b0;
        --color-text-placeholder: #505060;
        --color-primary: #3b82f6;
        --color-primary-light: #60a5fa;
        --color-primary-hover: #2563eb;
        --color-primary-glow: rgba(59, 130, 246, 0.3);
        --font-sans: 'Inter', sans-serif;
        --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
      }
      body {
        font-family: var(--font-sans);
        background-color: var(--color-background);
        background-image: 
            radial-gradient(circle at 1% 1%, rgba(59, 130, 246, 0.15) 0%, transparent 20%),
            radial-gradient(circle at 99% 99%, rgba(59, 130, 246, 0.1) 0%, transparent 25%),
            radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.02) 0%, transparent 15%);
        background-attachment: fixed;
      }
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background: var(--color-background);
      }
      ::-webkit-scrollbar-thumb {
        background-color: #2a2a3a;
        border-radius: 5px;
        border: 2px solid var(--color-background);
      }
      ::-webkit-scrollbar-thumb:hover {
        background-color: #404050;
      }
      .btn {
        @apply inline-flex items-center justify-center font-semibold py-2 px-4 rounded-lg transition-all duration-200 ease-in-out transform focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background;
      }
      .btn-primary {
        @apply bg-blue-600 text-white hover:bg-blue-500 focus:ring-blue-500 shadow-lg shadow-blue-900/50 border border-blue-500;
      }
      .btn-primary:hover:not(:disabled) {
        @apply scale-105 shadow-xl shadow-blue-900/60;
      }
      .btn-featured {
        @apply bg-gradient-to-r from-purple-600 to-blue-600 text-white hover:from-purple-500 hover:to-blue-500 focus:ring-purple-500 shadow-lg shadow-purple-900/50 border border-purple-500;
      }
      .btn-featured:hover:not(:disabled) {
        @apply scale-105 shadow-xl shadow-purple-900/60;
      }
      .btn-secondary {
        @apply bg-gray-700/50 text-gray-200 hover:bg-gray-700/80 focus:ring-gray-500 border border-gray-600/80;
      }
      .input-base {
        @apply w-full bg-gray-950/50 border border-gray-700 rounded-lg text-white transition-all duration-200 placeholder:text-text-placeholder;
        @apply focus:border-blue-500 focus:ring-1 focus:ring-blue-500 focus:bg-gray-900;
      }
      
      .premium-panel {
          @apply bg-panel/50 border border-border rounded-2xl shadow-2xl;
      }
      
      /* --- Animations --- */
      @keyframes fade-in {
        from { opacity: 0; transform: scale(0.98); }
        to { opacity: 1; transform: scale(1); }
      }
      .animate-fade-in { animation: fade-in 0.4s var(--ease-out-expo) forwards; }
      
      @keyframes fade-in-up {
        from { opacity: 0; transform: translateY(16px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in-up { animation: fade-in-up 0.5s var(--ease-out-expo) forwards; }

      @keyframes fade-out-down {
        from { opacity: 1; transform: translateY(0); }
        to { opacity: 0; transform: translateY(16px); }
      }
      .animate-fade-out-down { animation: fade-out-down 0.3s var(--ease-out-expo) forwards; }

      @keyframes modal-pop {
        from { opacity: 0; transform: translateY(16px) scale(0.97); }
        to { opacity: 1; transform: translateY(0) scale(1); }
      }
      .animate-modal-pop { animation: modal-pop 0.4s var(--ease-out-expo) forwards; }

      @keyframes count-up {
        from { opacity: 0; transform: translateY(16px) scale(0.9); filter: blur(2px); }
        to { opacity: 1; transform: translateY(0px) scale(1); filter: blur(0); }
      }
      .animate-count-up { animation: count-up 0.6s var(--ease-out-expo) forwards; }
      
      @keyframes flash-success {
        0% { background-color: rgba(34, 197, 94, 0.2); box-shadow: 0 0 16px rgba(34, 197, 94, 0.4); border-color: rgba(34, 197, 94, 0.6); }
        100% { background-color: transparent; box-shadow: none; border-color: var(--color-border); }
      }
      .animate-flash-success {
        animation: flash-success 1.2s ease-out forwards;
      }

      @keyframes subtle-glow {
        0%, 100% { box-shadow: 0 0 10px var(--color-primary-glow), 0 0 14px var(--color-primary-glow); opacity: 0.8; }
        50% { box-shadow: 0 0 20px var(--color-primary-glow), 0 0 28px var(--color-primary-glow); opacity: 1; }
      }
      .animate-subtle-glow {
        animation: subtle-glow 3.5s ease-in-out infinite;
      }

      /* --- Assistant Animations --- */
      @keyframes orb-pulse {
        0%, 100% { transform: scale(1); box-shadow: 0 0 15px var(--color-primary-glow), 0 0 25px var(--color-primary-glow); }
        50% { transform: scale(1.05); box-shadow: 0 0 25px var(--color-primary-glow), 0 0 40px var(--color-primary-glow); }
      }
      .animate-orb-pulse { animation: orb-pulse 3s ease-in-out infinite; }

      @keyframes fan-in {
        from { opacity: 0; transform: translateY(10px) rotate(-15deg) scale(0.8); }
        to { opacity: 1; transform: translateY(0) rotate(0) scale(1); }
      }
      .animate-fan-in { animation: fan-in 0.3s var(--ease-out-expo) forwards; }

      @keyframes ripple {
        0% { transform: scale(0.8); opacity: 1; }
        100% { transform: scale(2.5); opacity: 0; }
      }
      .animate-ripple { animation: ripple 1.5s ease-out infinite; }
      
      @keyframes waveform-bar {
        0%, 100% { height: 10%; }
        50% { height: 100%; }
      }
    </style>
<script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.20.0",
    "process": "https://aistudiocdn.com/process@^0.11.10",
    "dotenv": "https://aistudiocdn.com/dotenv@^17.2.2",
    "node-fetch": "https://aistudiocdn.com/node-fetch@^3.3.2",
    "buffer": "https://aistudiocdn.com/buffer@^6.0.3",
    "sqlite3": "https://aistudiocdn.com/sqlite3@^5.1.7",
    "yargs": "https://aistudiocdn.com/yargs@^18.0.0",
    "yargs/": "https://aistudiocdn.com/yargs@^18.0.0/",
    "recharts": "https://aistudiocdn.com/recharts@^2.12.7",
    "firebase/app": "https://aistudiocdn.com/firebase@^12.5.0/app",
    "firebase/auth": "https://aistudiocdn.com/firebase@^12.5.0/auth",
    "firebase/firestore": "https://aistudiocdn.com/firebase@^12.5.0/firestore",
    "firebase/": "https://aistudiocdn.com/firebase@^12.5.0/"
  }
}
</script>
</head>
<body class="h-full bg-background text-text-primary">
    <div id="root" class="h-full"></div>
    <script type="module" src="/index.tsx"></script>
</body>
</html>
]]>
  </file>
  <file path="types.ts">
    <![CDATA[
import { GenerateContentResponse, Type as GenaiType } from "@google/genai";

export const Type = GenaiType;

export interface GlobalSettings {
  googleAuthClientId?: string;
  googleAuthClientSecret?: string;
  googleApiKey?: string;
  supabaseConnection?: SupabaseConnection;
  paystackConnection?: PaystackConnection;
  payfastConnection?: PayfastConnection;
  wiseConnection?: WiseConnection;
  payoneerConnection?: PayoneerConnection;
  stripeConnection?: StripeConnection;
  payPalConnection?: PayPalConnection;
  activePaymentGateway?: 'paystack' | 'payfast' | 'wise' | 'payoneer' | 'stripe' | 'paypal';
}

export interface SupabaseConnection {
  url: string;
  anonKey: string;
  status: 'connected' | 'disconnected' | 'error';
  statusMessage?: string;
}

export interface PaystackConnection {
  publicKey: string;
  secretKey: string;
  status: 'connected' | 'disconnected' | 'error';
  statusMessage?: string;
}

export interface PayfastConnection {
  merchantId: string;
  merchantKey: string;
  passphrase?: string;
  status: 'connected' | 'disconnected' | 'error';
  statusMessage?: string;
}

export interface WiseConnection {
  apiKey: string;
  status: 'connected' | 'disconnected' | 'error';
  statusMessage?: string;
}

export interface PayoneerConnection {
    partnerId: string;
    programId: string;
    apiKey: string;
    status: 'connected' | 'disconnected' | 'error';
    statusMessage?: string;
}

export interface StripeConnection {
  publicKey: string;
  secretKey: string;
  status: 'connected' | 'disconnected' | 'error';
  statusMessage?: string;
}

export interface PayPalConnection {
  clientId: string;
  clientSecret: string;
  status: 'connected' | 'disconnected' | 'error';
  statusMessage?: string;
}

export type SubscriptionPlan = 'free' | 'creator' | 'pro' | 'agency';

export interface User {
  uid: string; // Firebase User ID
  email: string;
  username?: string;
  firstName?: string;
  lastName?: string;
  profilePictureUrl?: string;
  isAdmin?: boolean;
  subscriptionPlan?: SubscriptionPlan;
  subscriptionCycle?: 'monthly' | 'yearly';
  monthlyGenerations?: {
    count: number;
    resetDate: number; // Unix timestamp in ms for when the count was last reset
  };
  trialEndsAt?: number; // Unix timestamp in ms for trial end
}

export interface StrategySuggestion {
  title: string;
  reasoning: string;
  contentIdeas: string[];
}

export enum AppStatus {
  IDLE,
  GENERATING_STRATEGY,
  GENERATING_ARTICLE,
  GENERATING_IMAGE,
  CORRECTING_SEO,
  READY_TO_PUBLISH,
  PUBLISHING,
  GENERATING_SOCIAL_POSTS,
  PUBLISHED,
  ERROR,
}

export enum AiProvider {
  GOOGLE = 'GOOGLE',
  OPENROUTER = 'OPENROUTER',
  OPENAI = 'OPENAI',
  ANTHROPIC = 'ANTHROPIC',
  XAI = 'XAI',
  REPLICATE = 'REPLICATE',
  OPENART = 'OPENART',
}

export interface ApiKeys {
  google: string;
  openAI: string;
  anthropic: string;
  openRouter: string;
  xai: string;
  replicate: string;
  openArt: string;
  dataforseo: string;
}

export interface WordPressCredentials {
  url: string;
  username: string;
  password: string;
}

export interface ModelConfig {
  textProvider: AiProvider;
  textModel: string;
  imageProvider: AiProvider;
  imageModel: string;
  videoProvider: AiProvider;
  videoModel: string;
}

export interface StrategicBrief {
  focusKeyword: string;
  userIntent: 'Informational' | 'Commercial' | 'Transactional' | 'Navigational';
  keyEntities: string[];
  recommendedSchema: 'Article' | 'HowTo' | 'FAQPage' | 'Review' | 'LocalBusiness' | 'None';
  suggestedOutline: { heading: string; subheadings: string[] }[];
  /**
   * the cluster of related keywords.
   * Must be intelligently SEO targeted in the blog post for multiple keyword targeting.
   */
  keywordCluster: string[];
  contentAngle: string;
  seoTitle: string;
  metaDescription: string;
  slug: string;
  imagePrompt: string;
  faq: string[]; // Array of questions
  categories: string[];
  authorName?: string;
  localSeoBusinessName?: string;
  localSeoServiceArea?: string;
  localSeoPhoneNumber?: string;
  externalLinkSuggestions?: { title: string; url: string; }[];
}

export interface BlogPost {
  title: string;
  content: string; // HTML format
  seoTitle: string;
  metaDescription: string;
  slug: string;
  excerpt: string;
  categories: string[];
  tags: string[];
  imageUrl: string; // base64 data url
  imagePrompt: string;
  imageAltText: string;
  imageCaption: string;
  imageDescription: string;
  focusKeyword: string;
  wasSeoAutoCorrected?: boolean;
}

export interface ReferenceItem {
  id: string;
  type: 'url' | 'file';
  value: string; // URL string or Base64 data URL
  name: string | null;
  mimeType: string | null;
}

export interface RssItem {
  guid: string;
  title: string;
  link: string;
  contentSnippet: string;
}

export interface VideoSource {
  id: string;
  url: string; // The URL of the video or the channel RSS feed
  type: 'video' | 'channel';
  name: string; // Display name for the source
  processedVideoGuids: string[]; // For channels, tracks processed videos. For single videos, contains its own URL if processed.
}

export interface RssSource {
  id: string;
  url: string;
  name: string;
  processedRssGuids: string[];
}

export interface GoogleSheetSource {
  id: string;
  url: string;
  name: string;
  processedGoogleSheetRows: number[];
}

export interface RecurringSchedule {
  id:string;
  type: 'weekly' | 'monthly';
  days: number[]; // 0 (Sun) - 6 (Sat) for weekly, 1-31 for monthly
  time: string; // "HH:mm" format
  isEnabled: boolean;
  lastRun?: number; // Unix timestamp in ms
}

export interface SocialMediaPost {
    content: string;
    hashtags: string[];
}

export interface DistributionCampaignAsset {
  id: string;
  platform: 'twitter' | 'linkedin' | 'instagram' | 'audio';
  type: 'thread' | 'post' | 'carousel' | 'summary';
  content: any; // string for post, string[] for thread, { text: string; imagePrompt: string; imageUrl?: string }[] for carousel, string for audio (base64)
  status: 'draft' | 'approved' | 'published' | 'error';
  error?: string;
}

export interface DistributionCampaign {
  status: 'none' | 'generating' | 'generated';
  assets: DistributionCampaignAsset[];
}

export interface PostHistoryItem {
  id: string;
  topic: string;
  url: string;
  date: number; // Unix timestamp in ms
  type: 'Keyword' | 'RSS' | 'Video' | 'Social Graphic' | 'Social Video' | 'Google Sheet' | 'Email Campaign' | 'Article Refresh' | 'Agency Agent' | 'Creator Studio';
  socialMediaPosts?: Record<string, SocialMediaPost>;
  socialGraphics?: Record<string, { imageUrl: string; caption: string; }>;
  socialVideos?: Record<string, { videoUrl: string; caption: string; mcpId?: string }>;
  emailCampaigns?: { subject: string; body: string; };
  analytics?: { pageviews: number; visitors: number; engagement: number; conversions: number; };
  clarityMetrics?: {
    pageviews: number;
    deadClicks: number;
    rageClicks: number;
    scrollDepth: number; // percentage
  };
  distributionCampaign?: DistributionCampaign;
}

export type SocialAccountStatus = 'connected' | 'disconnected' | 'needs_reauth' | 'error';

export interface SocialMediaAccount {
    id: string;
    name: string;
    isAutomationEnabled: boolean;
    isConnected: boolean;
    accessToken?: string | null;
    clientId?: string;
    clientSecret?: string;
    destinationType?: 'profile' | 'page' | 'group';
    destinationId?: string;
    status: SocialAccountStatus;
    statusMessage?: string;
    extraData?: {
        channelName?: string;
    };
}

export interface WhatsAppAccount {
    id: string;
    name: string;
    isAutomationEnabled: boolean;
    isConnected: boolean;
    accessToken: string;
    phoneNumberId: string;
    destination: string; // Recipient phone number or group ID
    destinationType: 'number' | 'group';
    status: SocialAccountStatus;
    statusMessage?: string;
}

export interface TelegramAccount {
    id: string;
    name: string;
    isAutomationEnabled: boolean;
    isConnected: boolean;
    botToken: string;
    chatId: string; // e.g., @yourchannel or numeric ID
    status: SocialAccountStatus;
    statusMessage?: string;
}

export interface MetaAsset {
    id: string; // The ID of the page or account
    name: string;
    platform: 'facebook' | 'instagram';
    isEnabled: boolean;
}

export interface MetaConnection {
    id: string; // a UUID for this connection instance
    name: string; // User's name from Meta, e.g., "John Doe"
    userId: string; // Meta User ID
    userAccessToken: string;
    isConnected: boolean;
    status: SocialAccountStatus;
    statusMessage?: string;
    assets: MetaAsset[];
}

export interface MetaAdsAccount {
    id: string; // The Ad Account ID, e.g., "act_12345"
    name: string;
    isEnabled: boolean;
}

export interface MetaAdsConnection {
    id: string; // a UUID for this connection instance
    name: string; // User's name from Meta, e.g., "John Doe"
    userId: string; // Meta User ID
    userAccessToken: string;
    isConnected: boolean;
    status: SocialAccountStatus;
    statusMessage?: string;
    adAccounts: MetaAdsAccount[];
}

export interface GoogleAdsAccount {
    id: string; // The Ad Account ID, e.g., "customers/12345"
    name: string;
    isEnabled: boolean;
}

export interface GoogleAdsConnection {
    id: string; // a UUID for this connection instance
    name: string; // User's name from Google, e.g., "John Doe"
    userAccessToken: string;
    isConnected: boolean;
    status: SocialAccountStatus;
    statusMessage?: string;
    adAccounts: GoogleAdsAccount[];
}


export interface SocialMediaSettings {
    twitter: SocialMediaAccount[];
    facebook: SocialMediaAccount[];
    linkedin: SocialMediaAccount[];
    instagram: SocialMediaAccount[];
    meta?: MetaConnection[];
    metaClientId?: string;
    metaClientSecret?: string;
    meta_ads?: MetaAdsConnection[];
    metaAdsClientId?: string;
    metaAdsClientSecret?: string;
    google_ads?: GoogleAdsConnection[];
    googleAdsClientId?: string;
    googleAdsClientSecret?: string;
    googleCalendarClientId?: string;
    googleCalendarClientSecret?: string;
    pinterest: SocialMediaAccount[];
    whatsapp: WhatsAppAccount[];
    youtube: SocialMediaAccount[];
    tiktok: SocialMediaAccount[];
    telegram: TelegramAccount[];
    snapchat: SocialMediaAccount[];
}

export interface Draft {
  id: string;
  date: number;
  sourceTopic: string;
  sourceDetails: {
    type: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'refresh_url' | 'agency_agent';
    value: any; // Can be keyword string, RssItem, etc.
    source?: VideoSource | RssSource | GoogleSheetSource;
    videoItem?: RssItem; // For specific video from a channel
    rowIndex?: number;
  };
  strategicBrief: StrategicBrief;
  blogPost: BlogPost;
}

export interface CharacterReference {
  id: string;
  name: string;
  personality: string;
  visualPrompt: string;
  referenceImageUrl?: string; // Base64 data URL
}

export interface ImageGalleryItem {
  id: string;
  imageUrl: string; // base64 data URL
  altText: string;
  tags: string[];
}

export interface MonitoredBacklink {
  id: string;
  backlinkUrl: string;
  targetUrl: string;
  status: 'monitoring' | 'active' | 'inactive' | 'not_found' | 'error';
  statusMessage?: string;
  anchorText: string | null;
  lastChecked: number;
}

export interface McpServer {
    id: string;
    label: string;
    url: string;
    accessToken: string;
}

export interface MailchimpSettings {
    apiKey: string;
    serverPrefix: string;
    defaultListId: string;
    isConnected: boolean;
    statusMessage?: string;
}

export interface GoogleAnalyticsSettings {
    isConnected: boolean;
    clientId?: string;
    clientSecret?: string;
    accessToken?: string;
    propertyId?: string;
    propertyName?: string;
    selectedGoalId?: string;
    statusMessage?: string;
    availableProperties?: { id: string; name: string }[];
    availableGoals?: { id: string; name: string }[];
}

export interface GoogleCalendar {
  id: string;
  summary: string;
  primary?: boolean;
}

export interface GoogleCalendarConnection {
  isConnected: boolean;
  accessToken?: string;
  statusMessage?: string;
  primaryCalendarId?: string;
  availableCalendars?: GoogleCalendar[];
}

export interface SpecificDayEntry {
  id: string;
  type: 'specific_day';
  day: number; // 1-31
  topic: string;
}

export type OrdinalWeek = 'first' | 'second' | 'third' | 'fourth' | 'last';

export interface OrdinalDayEntry {
  id: string;
  type: 'ordinal_day';
  week: OrdinalWeek;
  dayOfWeek: number; // 0-6 for Sunday-Saturday
  topic: string;
}

export type MonthlyCalendarEntry = SpecificDayEntry | OrdinalDayEntry;

export interface ContentCalendar {
    weekly: string[]; // Array of 7 strings, index 0 is Sunday
    monthly: MonthlyCalendarEntry[];
}

export interface AgencyAgentLog {
  id: string;
  timestamp: number;
  type: 'info' | 'trend' | 'schedule' | 'complete' | 'error' | 'check';
  message: string;
  details?: any;
}

export interface AgentScheduledPost {
  id: string;
  topic: string;
  suggestedTime: number; // Unix timestamp in ms
  status: 'pending' | 'processing' | 'complete' | 'error';
  reasoning?: string;
  error?: string;
  resultingPostId?: string; // id from PostHistoryItem
}

export interface LiveBroadcastClip {
  id: string;
  videoUrl: string;
  caption: string;
  mcpId?: string;
  scheduledDay: number; // 0=Sun, 1=Mon...
  scheduledTime: string; // "HH:mm" format
  status: 'pending' | 'posted' | 'error';
  error?: string;
  postedAt?: number;
  postedTo?: string[]; // platform names
}

export interface LiveBroadcastAutomation {
  isEnabled: boolean;
  sourceType: 'meta' | 'facebook_url' | 'youtube' | 'tiktok' | 'x';
  facebookPageId: string;
  facebookPageUrl: string;
  
  youtubeSourceMethod?: 'account' | 'url';
  youtubeAccountId?: string;
  youtubeChannelUrl: string;

  tiktokSourceMethod?: 'account' | 'url';
  tiktokAccountId?: string;
  tiktokProfileUrl: string;
  
  xSourceMethod?: 'account' | 'url';
  xAccountId?: string;
  xProfileUrl: string;

  scheduleType: 'monitor' | 'scheduled';
  broadcastDay: number; // 0-6 for Sun-Sat
  broadcastStartTime: string; // HH:mm
  broadcastEndTime: string; // HH:mm
  dailyPostTimes: string[]; // "HH:mm" format, e.g., ['09:00', '17:00']
  lastProcessedVideoId?: string;
  status: 'idle' | 'monitoring' | 'processing' | 'scheduling' | 'complete' | 'error';
  statusMessage?: string;
  currentWeekClips: LiveBroadcastClip[];
  lastRunTimestamp?: number;
}

export enum AutomationWorkflow {
    Blog = 'blog',
    Social = 'social',
    Live = 'live',
    Email = 'email',
    Creator = 'creator'
}

export interface CreatorProject {
    id: string;
    idea: string;
    script: any;
    storyboard: { scene: number; imageUrl: string; prompt: string }[];
    videoUrl: string;
    voiceoverAudio: string;
    caption: string;
}

export interface Site {
  id:string;
  ownerId?: string; // Firebase User ID
  name:string;
  wordpressUrl:string;
  wordpressUsername:string;
  applicationPassword:string;
  brandGuideline:string;
  brandLogoLight?: string; // For dark backgrounds
  brandLogoDark?: string; // For light backgrounds
  brandColors?: string; // Comma-separated list
  brandFonts?: string; // Comma-separated list
  characterReferences?: CharacterReference[];
  imageGallery?: ImageGalleryItem[];
  isIntelligentGalleryEnabled?: boolean;
  isContentCalendarEnabled?: boolean;
  contentCalendar?: ContentCalendar;
  promoLink1:string;
  promoLink2:string;
  keywordList:string;
  videoSources: VideoSource[];
  rssSources: RssSource[];
  googleSheetSources: GoogleSheetSource[];
  references: ReferenceItem[];
  monitoredBacklinks: MonitoredBacklink[];
  authorName:string;
  authorId?: number;
  availableAuthors?: { id: number; name: string; }[];
  availableCategories?: { id: number; name: string; }[];
  isStrictCategoryMatching?: boolean;
  history: PostHistoryItem[];
  monthlyGenerationsCount?: number;

  // Blog Post Automation
  isAutomationEnabled:boolean;
  isAutoPublishEnabled: boolean;
  automationTrigger: 'daily' | 'schedule';
  automationDailyTime: string;
  automationTimezone: string;
  lastAutoPilotRun?:number; // Unix timestamp in ms
  recurringSchedules: RecurringSchedule[];
  drafts: Draft[];
  isOmnipresenceAutomationEnabled?: boolean;
  isGoogleCalendarSyncEnabled?: boolean;
  
  // Blog Post Generation sources
  dailyGenerationSource: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'agency_agent';
  scheduleGenerationSource: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'agency_agent';
  isInPostImagesEnabled?: boolean;
  numberOfInPostImages?: number;
  
  socialMediaSettings: SocialMediaSettings;
  mailchimpSettings: MailchimpSettings;
  googleAnalyticsSettings: GoogleAnalyticsSettings;
  googleCalendarConnection?: GoogleCalendarConnection;
  clarityProjectId?: string;
  supabaseConnection?: SupabaseConnection;
  paystackConnection?: PaystackConnection;
  payfastConnection?: PayfastConnection;
  wiseConnection?: WiseConnection;
  payoneerConnection?: PayoneerConnection;
  stripeConnection?: StripeConnection;
  payPalConnection?: PayPalConnection;
  activePaymentGateway?: 'paystack' | 'payfast' | 'wise' | 'payoneer' | 'stripe' | 'paypal';

  // AI model and API key configuration
  modelConfig: ModelConfig;
  apiKeys: ApiKeys;
  apiUsage: Partial<Record<keyof ApiKeys, number>>;
  fetchedModels?: Partial<Record<AiProvider, { text: string[], image: string[], video?: string[] }>>;
  isAssistantEnabled?: boolean;
  isVoiceControlEnabled?: boolean;
  isVideoControlEnabled?: boolean;
  isTextControlEnabled?: boolean;
  
  // Social Graphics
  isSocialGraphicAutomationEnabled: boolean;
  isSocialGraphicAutoPublishEnabled?: boolean;
  socialGraphicAutomationTrigger: 'daily' | 'schedule';
  socialGraphicDailyTime: string;
  lastSocialGraphicAutoPilotRun?: number;
  socialGraphicRecurringSchedules: RecurringSchedule[];
  socialGraphicGenerationSource: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'newly_published_post';
  
  // Social Videos
  isSocialVideoAutomationEnabled: boolean;
  isSocialVideoAutoPublishEnabled?: boolean;
  socialVideoAutomationTrigger: 'daily' | 'schedule';
  socialVideoDailyTime: string;
  lastSocialVideoAutoPilotRun?: number;
  socialVideoRecurringSchedules: RecurringSchedule[];
  socialVideoGenerationSource: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'newly_published_post';

  // Email Marketing Automation
  isEmailMarketingAutomationEnabled: boolean;
  emailMarketingAutomationTrigger: 'daily' | 'schedule';
  emailMarketingDailyTime: string;
  lastEmailMarketingAutoPilotRun?: number;
  emailMarketingRecurringSchedules: RecurringSchedule[];
  emailMarketingGenerationSource: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'newly_published_post';

  // SEO & Geo-targeting
  seoDataProvider: 'google_search' | 'dataforseo' | 'standalone';
  isLocalSeoEnabled: boolean;
  localSeoServiceArea: string;
  localSeoBusinessName: string;
  localSeoPhoneNumber: string;

  // Agency Features
  isAgencyAgentEnabled?: boolean;
  agentCheckFrequencyHours?: number;
  agentActionOnDiscovery?: 'addToReviewList' | 'addToKeywordList';
  agencyAgentLogs?: AgencyAgentLog[];
  agentScheduledPosts?: AgentScheduledPost[];
  lastAgentRun?: number;

  // Live Production Features
  liveBroadcastAutomation?: LiveBroadcastAutomation;

  // Creator Studio
  creatorStudioPromptList?: string;
  isCreatorStudioAutomationEnabled?: boolean;
  creatorStudioAutoPublishEnabled?: boolean;
  creatorStudioAutomationTrigger?: 'daily' | 'schedule';
  creatorStudioDailyTime?: string;
  creatorStudioRecurringSchedules?: RecurringSchedule[];
  creatorStudioReviews?: CreatorProject[];
}

export interface SeoChecklist {
  // On-Page Basics
  titleLength: boolean;
  metaDescriptionLength: boolean;
  keywordInTitle: boolean;
  keywordInMetaDescription: boolean;
  keywordInSlug: boolean;
  keywordInIntroduction: boolean;

  // Semantic & Topical Authority
  entityCoverage: boolean;
  topicalDepth: boolean;

  // Content Quality
  contentLength: boolean;
  keywordDensity: boolean;
  keywordInHeading: boolean;
  readability: boolean;
  imageAltText: boolean;
  faqSection: boolean;
  sufficientHeadings: boolean;
  videoEmbed: boolean;

  // Authority & Trust (E-E-A-T)
  internalLinks: boolean;
  externalLinks: boolean;
  authorMention: boolean;
  aboutAuthorSection: boolean;
  schemaMarkup: boolean;
}


export interface SeoScoreResult {
  score: number;
  checklist: SeoChecklist;
}

export const AVAILABLE_MODELS = {
  [AiProvider.GOOGLE]: {
    text: ['gemini-2.5-flash', 'gemini-2.5-pro'],
    image: ['imagen-4.0-generate-001', 'gemini-2.5-flash-image'],
    video: ['veo-3.1-generate-preview', 'veo-3.1-fast-generate-preview'],
  },
  [AiProvider.OPENAI]: {
    text: ['gpt-4o', 'gpt-4-turbo', 'gpt-3.5-turbo-0125'],
    image: ['dall-e-3', 'dall-e-2'],
    video: [],
  },
  [AiProvider.ANTHROPIC]: {
    text: ['claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],
    image: [],
    video: [],
  },
  [AiProvider.OPENROUTER]: {
    text: [
        'openai/gpt-4o',
        'google/gemini-2.5-flash',
        'anthropic/claude-3.5-sonnet',
        'meta-llama/llama-3-70b-instruct',
        'mistralai/mistral-large',
    ],
    image: [
        'openai/dall-e-3',
        'google/imagen-3',
        'stabilityai/stable-diffusion-3',
    ],
    video: [],
  },
  [AiProvider.XAI]: {
    text: ['grok-1'],
    image: [],
    video: [],
  },
  [AiProvider.REPLICATE]: {
    text: [],
    image: [
        'stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b',
        'ai-forever/kandinsky-2.2:ea1addaab376f4dc227f5368bbd8eff901820fd1cc14ed8cad63b29249e9d463'
    ],
    video: [],
  },
  [AiProvider.OPENART]: {
    text: [],
    image: ['stable-diffusion-v1-5', 'dall-e-3', 'juggernaut-xl-v8'],
    video: ['openart-video-v1'],
  },
};
]]>
  </file>
  <file path="services/geminiService.ts">
    <![CDATA[
]]>
  </file>
  <file path="components/Icons.tsx">
    <![CDATA[
import React from 'react';

export const LogoIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" {...props}>
      <title>Zenith Engine AI Logo</title>
      <path d="M12 2L6 12H12L10 22L18 10H12L12 2Z" />
    </svg>
);

export const PenIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" {...props}>
    {title && <title>{title}</title>}
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.5L15.232 5.232z" />
  </svg>
);

export const WordPressIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" viewBox="0 0 24 24" fill="currentColor" {...props}>
    {title && <title>{title}</title>}
    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm6.52 14.53c-.2.2-.45.29-.71.29-.26 0-.51-.1-.71-.29l-2.12-2.12-2.12 2.12c-.2.2-.45.29-.71.29-.26 0-.51-.1-.71-.29l-3.54-3.54c-.2-.2-.29-.45-.29-.71s.1-.51.29-.71l3.54-3.54c.2-.2.45-.29.71-.29.26 0 .51.1.71.29l2.12 2.12 2.12-2.12c.2-.2.45-.29.71-.29.26 0 .51.1.71.29l3.54 3.54c.2.2.29.45.29.71s-.1.51-.29.71l-3.54 3.54z"/>
  </svg>
);

export const CheckCircleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2} {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
);

export const XCircleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
    </svg>
);

export const ExclamationTriangleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2} {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
    </svg>
);

export const LinkIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2} {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.536a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1" />
    </svg>
);

export const UserIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2} {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
    </svg>
);

export const KeyIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2} {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.629 5.629l-2.371 2.371a2.121 2.121 0 01-3 0l-1.121-1.121a2.121 2.121 0 010-3l2.371-2.371A6 6 0 0121 11z" />
    </svg>
);

export const LightbulbIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2} {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
    </svg>
);

export const Cog6ToothIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-1.007 1.113-1.113l.448-.112a23.11 23.11 0 0 1 2.68 0l.448.112c.553.106 1.023.571 1.113 1.113l.064.385a23.11 23.11 0 0 1 0 2.68l-.064.385c-.09.542-.56 1.007-1.113 1.113l-.448.112a23.11 23.11 0 0 1-2.68 0l-.448-.112a1.125 1.125 0 0 1-1.113-1.113l-.064-.385a23.11 23.11 0 0 1 0-2.68l.064-.385ZM12 6.75a5.25 5.25 0 1 0 0 10.5 5.25 5.25 0 0 0 0-10.5ZM12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z" />
    </svg>
);

export const ClockIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
    </svg>
);

export const DocumentTextIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
    </svg>
);

export const ArchiveBoxIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="m20.25 7.5-.625 10.632a2.25 2.25 0 0 1-2.247 2.118H6.622a2.25 2.25 0 0 1-2.247-2.118L3.75 7.5M10 11.25h4M3.375 7.5h17.25c.621 0 1.125-.504 1.125-1.125v-1.5c0-.621-.504-1.125-1.125-1.125H3.375c-.621 0-1.125.504-1.125 1.125v1.5c0 .621.504 1.125 1.125 1.125Z" />
    </svg>
);

export const MenuIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
    </svg>
);
  
export const XIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M6 18 18 6M6 6l12 12" />
    </svg>
);

export const PhotoIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm16.5-16.5v16.5" />
    </svg>
);

export const VideoCameraIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9A2.25 2.25 0 0 0 13.5 5.25h-9a2.25 2.25 0 0 0-2.25 2.25v9A2.25 2.25 0 0 0 4.5 18.75Z" />
    </svg>
);

export const ArrowUpTrayIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
    </svg>
);

export const CalendarDaysIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0h18M12 15.75h.008v.008H12v-.008Z" />
    </svg>
);

export const TrashIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.134-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.067-2.09.92-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
    </svg>
);

export const RssIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M6.18,15.64A2.18,2.18,0,0,1,8.36,17.82H6.18A4.37,4.37,0,0,0,1.81,13.45V11.27A2.18,2.18,0,0,1,4,9.09V11.27A4.36,4.36,0,0,0,6.18,15.64M1.81,6.82V4H4A16,16,0,0,1,20,20H17.18A13.18,13.18,0,0,0,4,6.82H1.81M1.81,10.18V8.45A9.55,9.55,0,0,1,11.36,18H9.64A7.82,7.82,0,0,0,1.81,10.18Z" />
    </svg>
);

export const ShareIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.195.025.39.05.586.077a2.25 2.25 0 1 1-1.172 0c.196-.026.391-.051.586-.077ZM14.25 12a2.25 2.25 0 1 1 4.5 0 2.25 2.25 0 0 1-4.5 0Zm0 0h-5.167" />
    </svg>
);

export const BroadcastIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.042 21.672L13.682 16.072M21 21L15.042 21.672M15.042 21.672L11.25 16.072M11.25 16.072L7.458 21.672M11.25 16.072L15 12.75M15 12.75L18.75 16.072M15 12.75L11.25 9.428M11.25 9.428L7.5 12.75M11.25 9.428L15 6.104M7.5 12.75L3.75 9.428M7.5 12.75L4.282 16.072M3 3L8.958 3.672M8.958 3.672L11.25 9.428M8.958 3.672L13.682 3M11.25 9.428L13.682 3" />
    </svg>
);

export const SpeakerWaveIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
    </svg>
);

export const XIconSocial = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
    </svg>
);

export const FacebookIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M14 13.5h2.5l1-4H14v-2c0-1.03 0-2 2-2h1.5V2.14c-.326-.043-1.557-.14-2.857-.14C11.928 2 10 3.657 10 6.7v2.8H7v4h3V22h4z" />
    </svg>
);

export const LinkedInIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M19 0h-14c-2.761 0-5 2.239-5 5v14c0 2.761 2.239 5 5 5h14c2.762 0 5-2.239 5-5v-14c0-2.761-2.238-5-5-5zm-11 19h-3v-11h3v11zm-1.5-12.268c-.966 0-1.75-.79-1.75-1.764s.784-1.764 1.75-1.764 1.75.79 1.75 1.764-.783 1.764-1.75 1.764zm13.5 12.268h-3v-5.604c0-3.368-4-3.113-4 0v5.604h-3v-11h3v1.765c1.396-2.586 7-2.777 7 2.476v6.759z" />
    </svg>
);

export const InstagramIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.85s-.011 3.585-.069 4.85c-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07s-3.585-.012-4.85-.07c-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.85s.012-3.584.07-4.85c.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.85-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948s.014 3.667.072 4.947c.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072s3.667-.014 4.947-.072c4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.947s-.014-3.667-.072-4.947c-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.162 6.162 6.162 6.162-2.759 6.162-6.162-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4s1.791-4 4-4 4 1.79 4 4-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.441 1.441 1.441 1.441-.645 1.441-1.441-.645-1.44-1.441-1.44z" />
    </svg>
);

export const PinterestIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M12 2C6.48 2 2 6.48 2 12c0 4.11 2.53 7.63 6.01 9.07.03-.4.05-.88.16-1.3l1.19-5.09s-.3-.6-.3-1.48c0-1.39.81-2.43 1.82-2.43.86 0 1.27.64 1.27 1.41 0 .86-.55 2.14-.83 3.33-.24.99.5 1.8 1.48 1.8 1.77 0 3.14-1.88 3.14-4.6 0-2.42-1.74-4.13-4.22-4.13-2.85 0-4.51 2.13-4.51 4.35 0 .85.32 1.77.72 2.27.08.1.09.18.06.28l-.27.99c-.04.18-.14.22-.33.13-1.15-.55-1.88-2.2-1.88-3.56 0-2.92 2.12-5.63 6.2-5.63 3.28 0 5.82 2.34 5.82 5.4 0 3.24-2.06 5.85-4.96 5.85-1 0-1.92-.52-2.23-1.13l-.63 2.5c-.19.78-.71 1.77-1.07 2.3.89.28 1.83.43 2.8.43 5.52 0 10-4.48 10-10S17.52 2 12 2z" />
    </svg>
);

export const WhatsAppIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M12.04 2C6.58 2 2.13 6.45 2.13 11.91C2.13 13.66 2.59 15.36 3.45 16.86L2.05 22L7.31 20.62C8.75 21.41 10.36 21.85 12.04 21.85C17.5 21.85 21.95 17.4 21.95 11.94C21.95 6.48 17.5 2 12.04 2M12.04 3.63C16.56 3.63 20.32 7.39 20.32 11.94C20.32 16.49 16.56 20.22 12.04 20.22C10.56 20.22 9.14 19.83 7.9 19.11L7.53 18.9L4.45 19.75L5.33 16.75L5.12 16.38C4.33 15.05 3.76 13.53 3.76 11.93C3.76 7.38 7.52 3.63 12.04 3.63M9.23 7.33C9.03 7.33 8.84 7.34 8.66 7.37C8.26 7.42 7.93 7.6 7.63 7.89C7.32 8.19 6.8 8.73 6.8 9.71C6.8 10.69 7.34 11.62 7.47 11.78C7.6 11.94 9.04 14.19 11.28 15.11C13.14 15.87 13.54 15.79 13.9 15.75C14.54 15.68 15.24 15.05 15.46 14.4C15.67 13.75 15.67 13.18 15.61 13.09C15.55 13 15.39 12.95 15.19 12.85C14.99 12.75 13.81 12.18 13.59 12.1C13.37 12.02 13.22 11.99 13.07 12.19C12.92 12.39 12.44 12.96 12.31 13.12C12.18 13.28 12.06 13.31 11.85 13.23C11.65 13.15 10.86 12.9 9.91 12.08C9.17 11.45 8.69 10.66 8.57 10.46C8.45 10.26 8.56 10.15 8.68 10.03C8.78 9.93 8.91 9.77 9.04 9.62C9.17 9.47 9.22 9.37 9.32 9.17C9.42 8.97 9.37 8.82 9.31 8.69C9.25 8.56 8.87 7.7 8.71 7.34C8.56 7.02 8.4 6.95 8.23 6.95" />
    </svg>
);

export const YouTubeIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M10,15L15.19,12L10,9V15M21.56,7.17C21.69,7.64 21.78,8.27 21.84,9.07C21.91,9.87 21.94,10.56 21.94,11.16L22,12C22,14.19 21.84,15.8 21.56,16.83C21.31,17.73 20.73,18.31 19.83,18.56C19.36,18.69 18.73,18.78 17.93,18.84C17.13,18.91 16.44,18.94 15.84,18.94L15,19C12.81,19 11.2,18.84 10.17,18.56C9.27,18.31 8.69,17.73 8.44,16.83C8.31,16.36 8.22,15.73 8.16,14.93C8.09,14.13 8.06,13.44 8.06,12.84L8,12C8,9.81 8.16,8.2 8.44,7.17C8.69,6.27 9.27,5.69 10.17,5.44C11.2,5.16 12.81,5 15,5L15.84,5.06C16.44,5.06 17.13,5.09 17.93,5.16C18.73,5.22 19.36,5.31 19.83,5.44C20.73,5.69 21.31,6.27 21.56,7.17Z" />
    </svg>
);

export const TikTokIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M16.6,6.22C16.6,8.26 15.09,9.91 13.18,10.08V16.34C13.18,18.38 11.53,20.03 9.49,20.03C7.45,20.03 5.8,18.38 5.8,16.34C5.8,14.3 7.45,12.65 9.49,12.65C9.6,12.65 9.7,12.65 9.8,12.66V6.22C9.8,4.18 11.45,2.53 13.49,2.53C15.53,2.53 17.18,4.18 17.18,6.22H16.6Z" />
    </svg>
);

export const TelegramIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M9.78,18.65L10.26,14.21L18.73,7.45C19.29,6.96 18.8,6.06 18.19,6.4L7.44,12.44L3.1,11.05C2.08,10.72 2.09,9.24 3.12,8.91L20.53,2.37C21.42,2.06 22.34,2.94 22.06,3.82L17.34,20.1C17.06,21 15.6,21.05 15.3,20.15L11.7,15.8L9.78,18.65Z" />
    </svg>
);

export const SnapchatIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M9.1,6.36V6.35C9.1,6.35 9.1,6.35 9.1,6.36M12,8.06C13.1,8.06 14,8.96 14,10.06V10.07C14,10.07 14,10.07 14,10.06M9.1,6.36C8.83,5.26 8.3,4.46 7.22,4.46C6.93,4.46 6.64,4.53 6.36,4.68C4.54,5.61 4.25,7.75 5.18,9.57C5.23,9.67 5.28,9.78 5.33,9.88C5.33,9.88 5.33,9.88 5.34,9.88C5.34,9.88 5.34,9.88 5.34,9.88C5.81,10.83 6.81,11.23 7.25,11.23C7.5,11.23 7.7,11.19 7.88,11.12C8.75,10.83 9.1,10.04 9.1,9.11V9.1L9.1,6.36M12,8.06C10.9,8.06 10,8.96 10,10.06C10,10.07 10,10.07 10,10.07C10,11.17 10.9,12.07 12,12.07C13.1,12.07 14,11.17 14,10.07C14,10.07 14,10.07 14,10.06M22,6V18C22,19.11 21.1,20 20,20H4C2.89,20 2,19.11 2,18V6C2,4.89 2.89,4 4,4H20C21.1,4 22,4.89 22,6M14.9,9.09C14.9,9.09 14.9,9.09 14.9,9.09C14.9,10.03 14.25,10.82 13.12,11.11C13.3,11.18 13.5,11.22 13.75,11.22C14.19,11.22 15.19,10.82 15.66,9.88C15.66,9.88 15.67,9.88 15.67,9.88C15.67,9.88 15.67,9.88 15.67,9.88C15.72,9.78 15.77,9.67 15.82,9.57C16.75,7.75 16.46,5.61 14.64,4.68C14.36,4.53 14.07,4.46 13.78,4.46C12.7,4.46 12.17,5.26 11.9,6.36V6.35L11.9,9.1V9.11C11.9,10.04 12.25,10.83 13.12,11.11C13.12,11.11 13.12,11.12 13.12,11.11C12.4,11.45 12,12.18 12,13.06C12,14.16 12.9,15.06 14,15.06C15.1,15.06 16,14.16 16,13.06C16,12.18 15.6,11.45 14.88,11.11C14.88,11.12 14.88,11.11 14.88,11.11C14.88,11.11 14.88,11.11 14.88,11.11C15.75,10.83 16.1,10.04 16.1,9.11V9.1L16.1,6.35V6.36C15.83,5.26 15.3,4.46 14.22,4.46C14.22,4.46 14.22,4.46 14.22,4.46" />
    </svg>
);

export const MetaIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 24 24" {...props}>
        {title && <title>{title}</title>}
        <path d="M21.5,12c0,4.4-4.2,8-9.5,8S2.5,16.4,2.5,12c0-3.6,2.6-6.8,6.4-7.7l0.5,2.1c-2.3,0.8-3.9,2.9-3.9,5.6 c0,3.3,3.1,6,7.5,6s7.5-2.7,7.5-6c0-2.7-1.6-4.8-3.9-5.6l0.5-2.1C18.9,5.2,21.5,8.4,21.5,12z"/>
    </svg>
);

export const ArrowPathIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 11.667 0l3.181-3.183m-4.991-2.691v4.992h-4.992m0 0-3.181-3.183a8.25 8.25 0 0 1 11.667 0l3.181 3.183" />
    </svg>
);

export const CreditCardIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 8.25h19.5M2.25 9h19.5m-16.5 5.25h6m-6 2.25h3m-3.75 3h15a2.25 2.25 0 0 0 2.25-2.25V6.75A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25v10.5A2.25 2.25 0 0 0 4.5 19.5Z" />
    </svg>
);

export const ChevronDownIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
    </svg>
);

export const HomeIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path strokeLinecap="round" strokeLinejoin="round" d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" />
    </svg>
);

export const GoogleIcon = ({ title, ...props }: React.SVGProps<SVGSVGElement> & { title?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" {...props}>
        {title && <title>{title}</title>}
        <path d="M21.35,11.1H12.18V13.83H18.69C18.36,17.64 15.19,19.27 12.19,19.27C8.36,19.27 5,16.25 5,12C5,7.9 8.2,4.73 12.19,4.73C15.29,4.73 17.1,6.7 17.1,6.7L19,4.72C19,4.72 16.56,2 12.19,2C6.42,2 2.03,6.8 2.03,12C2.03,17.05 6.16,22 12.19,22C17.6,22 21.54,18.33 21.54,12.33C21.54,11.76 21.48,11.43 21.35,11.1Z" />
    </svg>
);

export const SparklesIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.898 20.575 16.5 21.75l-.398-1.175a3.375 3.375 0 0 0-2.31-2.31L12.75 18l1.175-.398a3.375 3.375 0 0 0 2.31-2.31L16.5 14.25l.398 1.175a3.375 3.375 0 0 0 2.31 2.31L20.25 18l-1.175.398a3.375 3.375 0 0 0-2.31 2.31Z" />
    </svg>
);

export const MicrophoneIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 18.75a6 6 0 0 0 6-6V7.5a6 6 0 0 0-12 0v5.25a6 6 0 0 0 6 6Z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 12a7.5 7.5 0 1 1-15 0" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v.75m0 15V21" />
    </svg>
);

export const ScaleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v17.25m0 0c-1.472 0-2.882.265-4.185.75M12 20.25c1.472 0 2.882.265 4.185.75M18.75 4.97A48.416 48.416 0 0 0 12 4.5c-2.291 0-4.545.16-6.75.47m13.5 0c1.01.143 2.01.317 3 .52m-3-.52v1.666c0 .434-.162.858-.437 1.187a1.534 1.534 0 0 1-1.186.437H5.623a1.534 1.534 0 0 1-1.186-.437A1.534 1.534 0 0 1 4 6.636V4.97M12 12.75a3.75 3.75 0 1 0 0-7.5 3.75 3.75 0 0 0 0 7.5Z" />
    </svg>
);

export const ChartBarIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z" />
    </svg>
);

export const QuestionMarkCircleIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z" />
    </svg>
);

export const SignOutIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15m3 0 3-3m0 0-3-3m3 3H9" />
    </svg>
);

export const LockClosedIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 0 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
    </svg>
);

export const BuildingOffice2Icon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 21h16.5M4.5 3h15M5.25 3v18m13.5-18v18M9 6.75h6M9 11.25h6M9 15.75h6M9 20.25h6M4.5 6.75h.75m-.75 3h.75m-.75 3h.75m-.75 3h.75m-.75 3h.75m13.5-13.5h-.75m.75 3h-.75m.75 3h-.75m.75 3h-.75m.75 3h-.75" />
    </svg>
);

export const NewspaperIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 7.5h1.5m-1.5 3h1.5m-7.5 3h7.5m-7.5 3h7.5m3-9h3.375c.621 0 1.125.504 1.125 1.125V18a2.25 2.25 0 0 1-2.25 2.25M16.5 7.5V18a2.25 2.25 0 0 0 2.25 2.25M16.5 7.5V4.875c0-.621-.504-1.125-1.125-1.125H4.125C3.504 3.75 3 4.254 3 4.875V18a2.25 2.25 0 0 0 2.25 2.25h13.5M6 7.5h3v3H6v-3Z" />
    </svg>
);

export const MailIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M21.75 6.75v10.5a2.25 2.25 0 0 1-2.25 2.25h-15a2.25 2.25 0 0 1-2.25-2.25V6.75m19.5 0A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25m19.5 0v.243a2.25 2.25 0 0 1-1.07 1.916l-7.5 4.615a2.25 2.25 0 0 1-2.36 0L3.32 8.91a2.25 2.25 0 0 1-1.07-1.916V6.75" />
    </svg>
);

export const BrainCircuitIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904L9 18.75l-.813-2.846a4.5 4.5 0 00-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 003.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 003.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 00-3.09 3.09zM18.259 8.715L18 9.75l-.259-1.035a3.375 3.375 0 00-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 002.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 002.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 00-2.456 2.456zM16.898 20.575L16.5 21.75l-.398-1.175a3.375 3.375 0 00-2.31-2.31L12.75 18l1.175-.398a3.375 3.375 0 002.31-2.31L16.5 14.25l.398 1.175a3.375 3.375 0 002.31 2.31L20.25 18l-1.175.398a3.375 3.375 0 00-2.31 2.31z" />
    </svg>
);

export const ClarityIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg fill="currentColor" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" {...props}><path d="M8 1.5A6.5 6.5 0 1 0 8 14.5A6.5 6.5 0 0 0 8 1.5Z M9.79 11.23A3.72 3.72 0 0 1 8 12.18A3.73 3.73 0 0 1 4.22 8.45A3.73 3.73 0 0 1 8 4.72A3.73 3.73 0 0 1 11.78 8.45A3.73 3.73 0 0 1 9.79 11.23Z" /><path d="M8 5.45A2.97 2.97 0 0 0 5 8.42A3 3 0 0 0 8 11.4A3 3 0 0 0 11 8.42A3 3 0 0 0 8 5.45Z" /></svg>
);

export const DeadClickIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg fill="none" stroke="currentColor" strokeWidth="1.5" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" {...props}><path d="M15.042 21.672L13.682 16.072M21 21l-5.958-.672M15.042 21.672L11.25 16.072M11.25 16.072L7.458 21.672M11.25 16.072L15 12.75M15 12.75l3.75 3.322M15 12.75l-3.75-3.322M11.25 9.428L7.5 12.75M11.25 9.428l3.75-3.322M7.5 12.75L3.75 9.428M7.5 12.75l-3.218 3.322M3 3l3.042 3.322M3 3l3.75 6.428M8.958 3.672L11.25 9.428m0 0l2.292-5.756m2.292 5.756l2.958-3.322m-2.958 3.322l-2.292 5.756M12 21a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z" strokeLinecap="round" strokeLinejoin="round" /></svg>
);

export const RageClickIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg fill="none" stroke="currentColor" strokeWidth="1.5" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" {...props}><path d="M15.042 21.672 13.682 16.072M21 21l-5.958-.672M15.042 21.672 11.25 16.072M11.25 16.072 7.458 21.672M11.25 16.072 15 12.75M15 12.75l3.75 3.322M15 12.75-3.75-3.322M11.25 9.428 7.5 12.75M11.25 9.428l3.75-3.322M7.5 12.75 3.75 9.428M7.5 12.75 4.282 16.072M3 3l3.042 3.322M3 3l3.75 6.428M8.958 3.672 11.25 9.428m0 0l2.292-5.756m2.292 5.756 2.958-3.322m-2.958 3.322-2.292 5.756" strokeLinecap="round" strokeLinejoin="round" /></svg>
);

export const ScrollDepthIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg fill="none" stroke="currentColor" strokeWidth="1.5" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" {...props}><path d="M9 3.75H6.912a2.25 2.25 0 0 0-2.15 1.95L3.13 18.355a2.25 2.25 0 0 0 2.15 2.495h13.44a2.25 2.25 0 0 0 2.15-2.495L17.088 5.7a2.25 2.25 0 0 0-2.15-1.95H15M9 3.75V3M9 3.75A2.25 2.25 0 0 1 11.25 6v.75M15 3.75V3m0 .75A2.25 2.25 0 0 0 12.75 6v.75m0 9.75h.008v.008h-.008v-.008Zm-3 0h.008v.008h-.008v-.008Zm-3 0h.008v.008h-.008v-.008Z" strokeLinecap="round" strokeLinejoin="round" /></svg>
);

export const EyeIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M2.036 12.322a1.012 1.012 0 0 1 0-.639l4.443-4.443a1.012 1.012 0 0 1 1.431 0l4.443 4.443a1.012 1.012 0 0 1 0 .639l-4.443 4.443a1.012 1.012 0 0 1-1.431 0l-4.443-4.443Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /></svg>
);

export const EyeSlashIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88" /></svg>
);

export const ChartPieIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z" /></svg>
);

export const TrendingUpIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="m2.25 18 9-9 4.5 4.5L21.75 6" /></svg>
);

export const ChatBubbleOvalLeftEllipsisIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M8.625 12a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H8.25m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H12m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.76 9.76 0 0 1-2.555-.337A5.972 5.972 0 0 1 5.41 20.97a5.969 5.969 0 0 1-.474-.065 4.48 4.48 0 0 0 .978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25Z" /></svg>
);

export const AtSymbolIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Zm0 0c0 1.657 1.007 3 2.25 3S21 13.657 21 12a9 9 0 1 0-2.636 6.364M16.5 12V8.25" /></svg>
);

export const CameraIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M6.827 6.175A2.31 2.31 0 0 1 5.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 0 0 2.25 2.25h15A2.25 2.25 0 0 0 21.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 0 0-1.134-.175 2.31 2.31 0 0 1-1.64-1.055l-.822-1.316a2.192 2.192 0 0 0-1.736-1.039 48.776 48.776 0 0 0-5.232 0 2.192 2.192 0 0 0-1.736 1.039l-.821 1.316Z" /><path strokeLinecap="round" strokeLinejoin="round" d="M16.5 12.75a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z" /></svg>
);

export const MagnifyingGlassIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" /></svg>
);

export const UsersIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M15 19.128a9.38 9.38 0 0 0 2.625.372 9.337 9.337 0 0 0 4.121-.952 4.125 4.125 0 0 0-7.53-2.493M15 19.128v-.003c0-1.113-.285-2.16-.786-3.07M15 19.128v.106A12.318 12.318 0 0 1 8.624 21c-2.331 0-4.512-.645-6.374-1.766l-.001-.109a6.375 6.375 0 0 1 11.964-4.663M12 12a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" />
    </svg>
);

export const ArrowRightIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3" /></svg>
);

export const ArrowUturnLeftIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}><path strokeLinecap="round" strokeLinejoin="round" d="M9 15 3 9m0 0 6-6M3 9h12a6 6 0 0 1 0 12h-3" /></svg>
);
]]>
  </file>
  <file path="components/MarkdownRenderer.tsx">
    <![CDATA[
]]>
  </file>
  <file path="App.tsx">
    <![CDATA[

import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
import { AppStatus, AiProvider, SubscriptionPlan, AutomationWorkflow } from './types';
import { AVAILABLE_MODELS } from './types';
import type { BlogPost, Site, RssItem, PostHistoryItem, ApiKeys, SocialMediaPost, SocialMediaSettings, Draft, WhatsAppAccount, TelegramAccount, SocialMediaAccount, StrategicBrief, SeoChecklist, RssSource, GoogleSheetSource, CharacterReference, MailchimpSettings, ModelConfig, GoogleAnalyticsSettings, User, MetaConnection, SupabaseConnection, MetaAsset, SocialAccountStatus, MetaAdsConnection, GoogleAdsConnection, PaystackConnection, PayfastConnection, WiseConnection, LiveBroadcastAutomation, GoogleCalendarConnection, PayoneerConnection, StripeConnection, PayPalConnection } from './types';
import { 
    generateStrategicBriefFromKeyword, generateArticleFromBrief, generateFeaturedImage, generateSocialMediaPosts, 
    generateSocialGraphicAndCaption, generateSocialVideoAndCaption, correctSeoIssues, discoverAndSelectBestKeyword, 
    suggestKeywords, postProcessArticleLinks, generateEmailCampaign, processGalleryImagesInHtml, selectImageFromGallery, 
    editImageFromGallery, _applyLogoToImage, processNewInPostImages, generateRefreshedArticleFromUrl 
} from './services/aiService';
import { publishPost, verifyWordPressConnection } from './services/wordpressService';
import { calculateSeoScore } from './services/seoService';
import * as oauthService from './services/oauthService';
import * as googleAnalyticsService from './services/googleAnalyticsService';
import * as googleCalendarService from './services/googleCalendarService';
import * as clarityService from './services/clarityService';
import { verifySupabaseConnection } from './services/dbService';
import { verifyPaystackConnection } from './services/paystackService';
import { verifyPayfastConnection } from './services/payfastService';
import { verifyWiseConnection } from './services/wiseService';
import { verifyPayoneerConnection } from './services/payoneerService';
import { verifyStripeConnection } from './services/stripeService';
import { verifyPayPalConnection } from './services/paypalService';
import { fetchAndParseRssFeed } from './services/rssService';
import { fetchSheetData } from './services/googleSheetService';
import * as socialMediaService from './services/socialMediaService';
import { getEnabledDestinations } from './services/socialMediaService';
import * as mailchimpService from './services/mailchimpService';
import { storageService } from './services/storageService';
import * as authService from './services/authService';
import { useToast } from './hooks/useToast';
import { 
    LogoIcon, CheckCircleIcon, ExclamationTriangleIcon, Cog6ToothIcon, ClockIcon, MenuIcon, XIcon, PenIcon, HomeIcon, 
    ScaleIcon, SparklesIcon, PhotoIcon, VideoCameraIcon, DocumentTextIcon, ShareIcon, LightbulbIcon, LinkIcon, 
    ChartBarIcon, QuestionMarkCircleIcon, SignOutIcon, UserIcon, CreditCardIcon, LockClosedIcon, WordPressIcon, 
    KeyIcon, BuildingOffice2Icon 
} from './components/Icons';
import { HistoryDetailViewer } from './components/HistoryDetailViewer';
import { AutomationDashboard } from './components/AutomationDashboard';
import { ArticleViewer } from './components/ArticleViewer';
import { SettingsTab } from './components/SettingsTab';
import { PublishSuccessViewer } from './components/PublishSuccessViewer';
import { DashboardTab } from './components/DashboardTab';
import { ContentHubTab } from './components/ContentHubTab';
import { GlobalAutomationTracker, AutomationJob } from './components/GlobalAutomationTracker';
import { AssistantUI } from './components/AssistantUI';
import { AuthorityTab } from './components/AuthorityTab';
import { ApiManagementTab } from './components/ApiManagementTab';
import { BrandingTab } from './components/BrandingTab';
import { ConnectionsTab } from './components/ConnectionsTab';
import { HelpGuide } from './components/HelpGuide';
import { AuthPage } from './components/AuthPage';
import { AdminDashboard } from './components/AdminDashboard';
import { ApiSpendDashboard } from './components/ApiSpendDashboard';
import { SubscriptionPage } from './components/SubscriptionPage';
import { UpgradePlan } from './components/UpgradePlan';
import { ProfileModal } from './components/ProfileModal';
import { AdvertisingTab } from './components/AdvertisingTab';
import { OnboardingWizard } from './components/OnboardingWizard';
import { checkAutomationReadiness } from './utils/automationReadiness';


const providerDisplayNames: Record<AiProvider, string> = {
  [AiProvider.GOOGLE]: 'Google',
  [AiProvider.OPENAI]: 'OpenAI',
  [AiProvider.OPENROUTER]: 'OpenRouter',
  [AiProvider.ANTHROPIC]: 'Anthropic',
  [AiProvider.XAI]: 'X.AI Grok',
  [AiProvider.REPLICATE]: 'Replicate',
  [AiProvider.OPENART]: 'OpenArt AI',
};

const APP_TITLE = 'Zenith Engine AI';

const planPillClasses: Record<string, string> = {
    creator: 'bg-cyan-400/10 text-cyan-300 border border-cyan-400/60 shadow-[0_0_8px_theme(colors.cyan.400/30)]',
    pro: 'bg-purple-400/10 text-purple-300 border border-purple-400/60 shadow-[0_0_8px_theme(colors.purple.400/30)]',
    agency: 'bg-yellow-400/10 text-yellow-300 border border-yellow-400/60 shadow-[0_0_8px_theme(colors.yellow.400/30)]',
};

interface ActiveComponentProps {
    status: AppStatus;
    blogPost: BlogPost | null;
    publishedPostUrl: string | null;
    lastGeneratedSocialPosts: Record<string, SocialMediaPost> | null;
    site: Site;
    sites: Site[];
    resetGeneration: () => void;
    handleConnectSocialMedia: (platform: keyof Omit<SocialMediaSettings, 'whatsapp' | 'telegram' | 'metaClientId' | 'metaClientSecret' | 'metaAdsClientId' | 'metaAdsClientSecret' | 'googleAdsClientId' | 'googleAdsClientSecret' | 'googleCalendarClientId' | 'googleCalendarClientSecret' | 'googleAuthClientId' | 'googleAuthClientSecret'> | 'google_analytics' | 'google_calendar', accountId: string) => void;
    isConnectingSocial: string | null;
    handleBlogPostUpdate: (updatedPost: BlogPost) => void;
    seoScore: any | null;
    statusMessage: string;
    handlePublish: () => void;
    isLoading: boolean;
    activeTab: string;
    activeSubTab: AutomationWorkflow | string | null;
    setActiveTab: (tab: string, subTab?: string | null) => void;
    generateAndScorePost: (topicToTrack: string, generationSource: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'agency_agent', sourceDetails: any, site: Site) => Promise<void>;
    handleReviewDraft: (draftId: string) => void;
    handleSiteUpdate: (field: keyof Site, value: any) => void;
    handleMultipleSiteUpdates: (updates: Partial<Site>) => void;
    setViewingHistoryItem: (item: PostHistoryItem | null) => void;
    logApiUsage: (provider: keyof ApiKeys, cost: number) => void;
    handleResetAllSitesSpend: () => void;
    handleOpenDeleteDialog: () => void;
    handleVerifySocialMediaConnection: (platformId: oauthService.SocialPlatform, accountId: string, accessToken: string) => void;
    handleVerifyCredentialBasedConnection: (platformId: 'whatsapp' | 'telegram', account: WhatsAppAccount | TelegramAccount) => void;
    onDiscardDraft: (draftId: string) => void;
    onRefreshAnalytics: () => Promise<void>;
    onRefreshClarityData: () => Promise<void>;
    currentUser: User;
    handleUpdatePlan: (plan: SubscriptionPlan, cycle?: 'monthly' | 'yearly') => Promise<void>;
    planAccess: any; // Add planAccess here
    onRefreshArticle: (url: string, site: Site) => Promise<void>;
    originalArticleForDiff: string | null;
    refreshedArticleForDiff: BlogPost | null;
    handleVerifyMailchimp: (settings: MailchimpSettings) => Promise<void>;
    handleVerifyClarity: (projectId: string) => Promise<void>;
    handleVerifySupabase: (connection: SupabaseConnection) => Promise<void>;
    handleVerifyPaystack: (connection: PaystackConnection) => Promise<void>;
    handleVerifyPayfast: (connection: PayfastConnection) => Promise<void>;
    handleVerifyWise: (connection: WiseConnection) => Promise<void>;
    handleVerifyPayoneer: (connection: PayoneerConnection) => Promise<void>;
    handleVerifyStripe: (connection: StripeConnection) => Promise<void>;
    handleVerifyPayPal: (connection: PayPalConnection) => Promise<void>;
}

const ActiveComponent: React.FC<ActiveComponentProps> = ({
    status, blogPost, publishedPostUrl, lastGeneratedSocialPosts, site, sites,
    resetGeneration, handleConnectSocialMedia, isConnectingSocial, handleBlogPostUpdate,
    seoScore, statusMessage, handlePublish, isLoading, activeTab, activeSubTab,
    setActiveTab, generateAndScorePost, handleReviewDraft, handleSiteUpdate,
    handleMultipleSiteUpdates, setViewingHistoryItem, logApiUsage, handleResetAllSitesSpend,
    handleOpenDeleteDialog, handleVerifySocialMediaConnection, handleVerifyCredentialBasedConnection,
    onDiscardDraft, onRefreshAnalytics, onRefreshClarityData, currentUser, handleUpdatePlan, planAccess,
    onRefreshArticle, originalArticleForDiff, refreshedArticleForDiff, handleVerifyMailchimp,
    handleVerifyClarity, handleVerifySupabase, handleVerifyPaystack, handleVerifyPayfast, handleVerifyWise,
    handleVerifyPayoneer, handleVerifyStripe, handleVerifyPayPal
}) => {
    if (status >= AppStatus.READY_TO_PUBLISH && blogPost) {
        if (status === AppStatus.PUBLISHED) {
            return <PublishSuccessViewer publishedPostUrl={publishedPostUrl} socialPosts={lastGeneratedSocialPosts} site={site} onReset={resetGeneration} onConnect={handleConnectSocialMedia as any} isConnectingSocial={isConnectingSocial} />
        }
        return <ArticleViewer blogPost={blogPost} seoScore={seoScore} status={status} statusMessage={statusMessage} onPublish={handlePublish} onCancel={resetGeneration} site={site} onUpdate={handleBlogPostUpdate} originalArticleForDiff={originalArticleForDiff} refreshedArticleForDiff={refreshedArticleForDiff} />;
    }

    if (isLoading) {
      const messages = [
        "Discovering high-intent keywords...",
        "Analyzing SERPs for competitive advantages...",
        "Crafting a unique angle for your post...",
        "Drafting compelling, SEO-optimized content...",
        "Generating a unique featured image...",
        "Performing Self-Correction SEO Loop...",
        "Finalizing SEO metadata and schema...",
      ];
      const messageIndex = Math.min(status - 1, messages.length - 1);

      return (
        <div className="text-center" role="status" aria-live="polite">
            <svg className="animate-spin h-12 w-12 text-blue-400 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <h2 className="text-xl font-bold mt-6 text-white">{statusMessage}</h2>
            <p className="text-text-secondary mt-2">{messages[messageIndex]}</p>
        </div>
      );
    }
    
    switch (activeTab) {
      case 'dashboard':
        return <DashboardTab site={site} sites={sites} setActiveTab={setActiveTab} onGenerate={generateAndScorePost} onReviewDraft={handleReviewDraft} currentUser={currentUser} />;
      case 'content':
        return <ContentHubTab 
                    site={site} 
                    onSiteUpdate={handleSiteUpdate} 
                    onMultipleSiteUpdates={handleMultipleSiteUpdates} 
                    onGenerateAndScore={generateAndScorePost} 
                    onReviewDraft={handleReviewDraft}
                    onDiscardDraft={onDiscardDraft}
                    onViewHistory={setViewingHistoryItem}
                    setActiveTab={setActiveTab}
                    logApiUsage={logApiUsage}
                    initialSubTab={activeSubTab}
                    onRefreshAnalytics={onRefreshAnalytics}
                    onRefreshClarityData={onRefreshClarityData}
                    onRefreshArticle={onRefreshArticle}
                />;
      case 'authority':
        if (!planAccess.canUseAuthority) return <UpgradePlan featureName="The Authority Suite" requiredPlan="Pro" setActiveTab={setActiveTab} />;
        return <AuthorityTab site={site} onSiteUpdate={handleSiteUpdate} logApiUsage={logApiUsage} />;
      case 'automation':
        if (!planAccess.canUseBlogAutomation) return <UpgradePlan featureName="Content Automation" requiredPlan="Creator" setActiveTab={setActiveTab} />;
        return <AutomationDashboard 
                    site={site} 
                    onSiteUpdate={handleSiteUpdate} 
                    onMultipleSiteUpdates={handleMultipleSiteUpdates} 
                    setActiveTab={setActiveTab} 
                    planAccess={planAccess} 
                    initialSubTab={activeSubTab}
                />;
      case 'advertising':
        if (!planAccess.canUseAdvertising) return <UpgradePlan featureName="Advertising Dashboard" requiredPlan="Pro" setActiveTab={setActiveTab} />;
        return <AdvertisingTab site={site} setActiveTab={setActiveTab} />;
      case 'branding':
        return <BrandingTab 
                    site={site} 
                    onSiteUpdate={handleSiteUpdate}
                    onMultipleSiteUpdates={handleMultipleSiteUpdates}
                    logApiUsage={logApiUsage}
                    setActiveTab={setActiveTab}
                />;
      case 'connections':
        return <ConnectionsTab
                    site={site}
                    onSiteUpdate={handleSiteUpdate}
                    onMultipleSiteUpdates={handleMultipleSiteUpdates}
                    isConnectingSocial={isConnectingSocial}
                    onConnect={handleConnectSocialMedia}
                    onVerify={handleVerifySocialMediaConnection}
                    onVerifyCredentials={handleVerifyCredentialBasedConnection}
                    onVerifyMailchimp={handleVerifyMailchimp}
                    onVerifyClarity={handleVerifyClarity}
                    onVerifySupabase={handleVerifySupabase}
                    onVerifyPaystack={handleVerifyPaystack}
                    onVerifyPayfast={handleVerifyPayfast}
                    onVerifyWise={handleVerifyWise}
                    onVerifyPayoneer={handleVerifyPayoneer}
                    onVerifyStripe={handleVerifyStripe}
                    onVerifyPayPal={handleVerifyPayPal}
                    setActiveTab={setActiveTab}
                    logApiUsage={logApiUsage}
                />;
      case 'analytics':
        if (!planAccess.canUseAnalytics) return <UpgradePlan featureName="Analytics & Monitoring" requiredPlan="Creator" setActiveTab={setActiveTab} />;
        return <ApiManagementTab
                    site={site}
                    setActiveTab={setActiveTab}
                    onSiteUpdate={handleSiteUpdate}
                    logApiUsage={logApiUsage}
                />;
      case 'api-spend':
        return <ApiSpendDashboard
                    site={site}
                    sites={sites}
                    onResetAllSitesSpend={handleResetAllSitesSpend}
                    onSiteUpdate={handleSiteUpdate}
                    currentUser={currentUser}
                />;
      case 'subscription':
        return <SubscriptionPage currentUser={currentUser} onUpdatePlan={handleUpdatePlan} />;
      case 'settings':
        return <SettingsTab 
                    site={site} 
                    onSiteUpdate={handleSiteUpdate} 
                    onMultipleSiteUpdates={handleMultipleSiteUpdates} 
                    onOpenDeleteDialog={handleOpenDeleteDialog}
                    setActiveTab={setActiveTab}
                />;
      default:
        return <div>Tab not found</div>;
    }
};


export const App: React.FC = () => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [authLoading, setAuthLoading] = useState(true);
  const [status, setStatus] = useState<AppStatus>(AppStatus.IDLE);
  const [statusMessage, setStatusMessage] = useState<string>('');
  const [blogPost, setBlogPost] = useState<BlogPost | null>(null);
  const [strategicBrief, setStrategicBrief] = useState<StrategicBrief | null>(null);
  const toast = useToast();
  const [publishedPostUrl, setPublishedPostUrl] = useState<string | null>(null);
  const [currentTopic, setCurrentTopic] = useState<string>('');
  const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'saved'>('idle');
  const saveTimeoutRef = useRef<number | null>(null);
  const isInitialMount = useRef(true);
  const [sites, setSites] = useState<Site[]>([]);
  const [selectedSiteId, setSelectedSiteId] = useState<string | null>(null);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const [deleteConfirmationInput, setDeleteConfirmationInput] = useState('');
  const [seoScore, setSeoScore] = useState<any | null>(null);
  const [viewingHistoryItem, setViewingHistoryItem] = useState<PostHistoryItem | null>(null);
  const [isConnectingSocial, setIsConnectingSocial] = useState<string | null>(null);
  const [currentGenerationSource, setCurrentGenerationSource] = useState<PostHistoryItem['type'] | null>(null);
  const [currentSourceDetails, setCurrentSourceDetails] = useState<any>(null);
  const [lastGeneratedSocialPosts, setLastGeneratedSocialPosts] = useState<Record<string, SocialMediaPost> | null>(null);
  const [reviewingDraft, setReviewingDraft] = useState<Draft | null>(null);
  const [isHelpGuideOpen, setIsHelpGuideOpen] = useState(false);
  const [impersonatingUser, setImpersonatingUser] = useState<User | null>(null);
  const [originalArticleForDiff, setOriginalArticleForDiff] = useState<string | null>(null);
  const [refreshedArticleForDiff, setRefreshedArticleForDiff] = useState<BlogPost | null>(null);
  const [isProfileModalOpen, setIsProfileModalOpen] = useState(false);
  
  const [isOnboarding, setIsOnboarding] = useState(false);
  const [isTrackerModalOpen, setIsTrackerModalOpen] = useState(false);
  
  const [activeTab, setActiveTabState] = useState('dashboard');
  const [activeSubTab, setActiveSubTab] = useState<AutomationWorkflow | string | null>(null);
  const [isTrialBannerVisible, setIsTrialBannerVisible] = useState(true);

  const setActiveTab = (tab: string, subTab: string | null = null) => {
      setActiveTabState(tab);
      setActiveSubTab(subTab);
      if (!subTab) {
          setActiveSubTab(null);
      }
      setIsSidebarOpen(false);
  };

  const selectedSite = sites.find(s => s.id === selectedSiteId);
  const isLoading = status > AppStatus.IDLE && status < AppStatus.READY_TO_PUBLISH;

  const automationReadiness = useMemo(() => {
    if (!selectedSite) return { blog: false, socialGraphic: false, socialVideo: false, email: false, liveProduction: false };
    return checkAutomationReadiness(selectedSite);
  }, [selectedSite]);

  const isAnyAutomationEnabled = useMemo(() => {
    if (!selectedSite) return false;
    return selectedSite.isAutomationEnabled || selectedSite.isSocialGraphicAutomationEnabled || selectedSite.isSocialVideoAutomationEnabled || selectedSite.isEmailMarketingAutomationEnabled || selectedSite.liveBroadcastAutomation?.isEnabled;
  }, [selectedSite]);

  const isAnyAutomationReady = useMemo(() => Object.values(automationReadiness).some(Boolean), [automationReadiness]);

  const automationStatusColor = useMemo(() => {
      if (!isAnyAutomationEnabled) return 'bg-gray-500'; // Disabled
      return isAnyAutomationReady ? 'bg-green-500' : 'bg-yellow-500'; // Ready or Misconfigured
  }, [isAnyAutomationEnabled, isAnyAutomationReady]);
  
  const trialDaysLeft = useMemo(() => {
    if (!currentUser?.trialEndsAt) return 0;
    const timeLeft = currentUser.trialEndsAt - Date.now();
    return Math.max(0, Math.ceil(timeLeft / (1000 * 60 * 60 * 24)));
  }, [currentUser]);

  const planAccess = useMemo(() => {
    const plan = currentUser?.subscriptionPlan || 'free';
    const planLevels: Record<SubscriptionPlan, number> = { free: 0, creator: 1, pro: 2, agency: 3 };
    const currentLevel = planLevels[plan];

    const generationLimits: Record<SubscriptionPlan, number> = {
        free: 2,
        creator: 50,
        pro: 200,
        agency: Infinity,
    };
    const siteLimits: Record<SubscriptionPlan, number> = {
        free: 1,
        creator: 1,
        pro: 10,
        agency: Infinity,
    };

    const monthlyGenerations = currentUser?.monthlyGenerations || { count: 0, resetDate: Date.now() };
    const limit = generationLimits[plan];
    const canGenerate = !!currentUser?.isAdmin || monthlyGenerations.count < limit;

    return {
        plan,
        canUseAnalytics: currentLevel >= planLevels.creator,
        canUseAuthority: currentLevel >= planLevels.pro,
        canUseAdvertising: currentLevel >= planLevels.pro,
        canUseAuthorityCommenting: currentLevel >= planLevels.pro,
        canUseAuthorityOutreach: currentLevel >= planLevels.agency,
        canUseBlogAutomation: currentLevel >= planLevels.free,
        canUseSocialAutomation: currentLevel >= planLevels.creator,
        canUseSocialGraphicsAutomation: currentLevel >= planLevels.creator,
        canUseSocialVideoAutomation: currentLevel >= planLevels.creator,
        canUseEmailMarketing: currentLevel >= planLevels.pro,
        canUseAdvancedBranding: currentLevel >= planLevels.creator,
        canUseCharacterPersonas: currentLevel >= planLevels.pro,
        canUseAdvancedConnections: currentLevel >= planLevels.creator,
        canUseMcp: currentLevel >= planLevels.agency,
        canUseDataForSeo: currentLevel >= planLevels.pro,
        canUseCustomModels: currentLevel >= planLevels.creator,
        canUseGoogleSheets: currentLevel >= planLevels.pro,
        canUseClientManagement: currentLevel >= planLevels.agency,
        canUseLiveProduction: currentLevel >= planLevels.pro,
        siteLimit: siteLimits[plan],
        generationLimit: limit,
        generationsUsed: monthlyGenerations.count,
        canGenerate,
    };
  }, [currentUser]);
  
  // --- AUTH & DATA LOADING ---
  const loadUserData = useCallback((user: User) => {
    try {
      const { sites: savedSites, lastSelectedId } = storageService.loadSitesAndLastId(user);
      let finalSites: Site[] = [];
      
      const defaultApiKeys: ApiKeys = { google: '', openAI: '', anthropic: '', openRouter: '', xai: '', replicate: '', openArt: '', dataforseo: '' };
      const defaultModelConfig: ModelConfig = {
        textProvider: AiProvider.GOOGLE, textModel: AVAILABLE_MODELS.GOOGLE.text[0],
        imageProvider: AiProvider.GOOGLE, imageModel: AVAILABLE_MODELS.GOOGLE.image[0],
        videoProvider: AiProvider.GOOGLE, videoModel: AVAILABLE_MODELS.GOOGLE.video[0],
      };
      const defaultSocialSettings: SocialMediaSettings = { twitter: [], facebook: [], linkedin: [], instagram: [], pinterest: [], whatsapp: [], youtube: [], tiktok: [], telegram: [], snapchat: [], meta: [], meta_ads: [], google_ads: [] };
      const defaultMailchimpSettings: MailchimpSettings = { apiKey: '', serverPrefix: '', defaultListId: '', isConnected: false };
      const defaultAnalyticsSettings: GoogleAnalyticsSettings = { isConnected: false };
      const defaultApiUsage: any = { google: 0, openAI: 0, anthropic: 0, openRouter: 0, xai: 0, replicate: 0, openArt: 0, dataforseo: 0 };
      const defaultSupabaseConnection: SupabaseConnection = { url: '', anonKey: '', status: 'disconnected' };
      const defaultPaystackConnection: PaystackConnection = { publicKey: '', secretKey: '', status: 'disconnected' };
      const defaultPayfastConnection: PayfastConnection = { merchantId: '', merchantKey: '', passphrase: '', status: 'disconnected' };
      const defaultWiseConnection: WiseConnection = { apiKey: '', status: 'disconnected' };
      const defaultPayoneerConnection: PayoneerConnection = { partnerId: '', programId: '', apiKey: '', status: 'disconnected' };
      const defaultStripeConnection: StripeConnection = { publicKey: '', secretKey: '', status: 'disconnected' };
      const defaultPayPalConnection: PayPalConnection = { clientId: '', clientSecret: '', status: 'disconnected' };
      const defaultLiveBroadcast: LiveBroadcastAutomation = { isEnabled: false, sourceType: 'meta', facebookPageId: '', facebookPageUrl: '', youtubeChannelUrl: '', tiktokProfileUrl: '', xProfileUrl: '', scheduleType: 'monitor', broadcastDay: 0, broadcastStartTime: '10:00', broadcastEndTime: '12:00', dailyPostTimes: ['09:00', '17:00'], status: 'idle', currentWeekClips: [], youtubeSourceMethod: 'url', tiktokSourceMethod: 'url', xSourceMethod: 'url' };
      const socialPlatforms: (keyof Omit<SocialMediaSettings, 'metaClientId'|'metaClientSecret'|'metaAdsClientId'|'metaAdsClientSecret'|'googleAdsClientId'|'googleAdsClientSecret'|'googleCalendarClientId'|'googleCalendarClientSecret' | 'googleAuthClientId' | 'googleAuthClientSecret'>)[] = ['twitter', 'facebook', 'linkedin', 'instagram', 'pinterest', 'whatsapp', 'youtube', 'tiktok', 'telegram', 'snapchat', 'meta', 'meta_ads', 'google_ads'];
      const defaultTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';

      if (savedSites) {
          finalSites = savedSites.map((site: any): Site => {
              
              const migratedModelConfig = { ...defaultModelConfig, ...(site.modelConfig || {}) };
              
              if (!site.apiKeys || !('dataforseo' in (site.apiKeys || {}))) {
                const oldConfig = site.modelConfig || {};
                const newApiKeys: ApiKeys = { ...defaultApiKeys, ...(site.apiKeys || {}) };

                if (oldConfig.apiKey) {
                    switch (oldConfig.provider) {
                        case AiProvider.OPENAI: newApiKeys.openAI = oldConfig.apiKey; break;
                        case AiProvider.ANTHROPIC: newApiKeys.anthropic = oldConfig.apiKey; break;
                        case AiProvider.OPENROUTER: newApiKeys.openRouter = oldConfig.apiKey; break;
                    }
                }
                
                migratedModelConfig.textProvider = oldConfig.provider || AiProvider.GOOGLE;
                migratedModelConfig.textModel = oldConfig.textModel || defaultModelConfig.textModel;
                migratedModelConfig.imageProvider = oldConfig.provider || AiProvider.GOOGLE;
                migratedModelConfig.imageModel = oldConfig.imageModel || defaultModelConfig.imageModel;

                if (migratedModelConfig.imageProvider === AiProvider.ANTHROPIC || migratedModelConfig.imageProvider === AiProvider.XAI) {
                    migratedModelConfig.imageProvider = AiProvider.GOOGLE;
                    migratedModelConfig.imageModel = defaultModelConfig.imageModel;
                }
                
                site.apiKeys = newApiKeys;
              }

              const generationSource = site.generationSource || 'keyword';
              let migratedSocialSettings = { ...defaultSocialSettings, ...(site.socialMediaSettings || {}) };

              let needsMigration = false;
              for (const platform of socialPlatforms) {
                  if (platform !== 'whatsapp' && platform !== 'telegram' && platform !== 'meta' && platform !== 'meta_ads' && platform !== 'google_ads' && migratedSocialSettings[platform] && !Array.isArray(migratedSocialSettings[platform])) {
                      needsMigration = true;
                      break;
                  }
                  if (!migratedSocialSettings[platform]) {
                    migratedSocialSettings[platform] = [];
                  }
              }

              if(needsMigration) {
                  const newSocialSettings: any = { ...defaultSocialSettings };
                  for (const platform of socialPlatforms) {
                       if (platform === 'whatsapp' || platform === 'telegram' || platform === 'meta' || platform === 'meta_ads' || platform === 'google_ads') {
                            newSocialSettings[platform] = migratedSocialSettings[platform] || [];
                            continue;
                       };
                      const platformSetting = migratedSocialSettings[platform];
                       if (platformSetting && typeof platformSetting === 'object' && !Array.isArray(platformSetting)) {
                            newSocialSettings[platform] = [{
                                id: crypto.randomUUID(),
                                name: `${platform.charAt(0).toUpperCase() + platform.slice(1)} Account`,
                                isAutomationEnabled: platformSetting.isAutomationEnabled ?? false,
                                isConnected: platformSetting.isConnected ?? false,
                                accessToken: platformSetting.accessToken,
                                clientId: platformSetting.clientId,
                                clientSecret: platformSetting.clientSecret,
                            }];
                       } else {
                            newSocialSettings[platform] = platformSetting || [];
                       }
                  }
                  migratedSocialSettings = newSocialSettings;
              }

              // Add status and destinationType to existing accounts
              for (const platform of socialPlatforms) {
                  if (migratedSocialSettings[platform]) {
                    migratedSocialSettings[platform] = (migratedSocialSettings[platform] as any[]).map((acc: any) => ({
                      ...acc,
                      status: acc.status || (acc.isConnected ? 'connected' : 'disconnected'),
                      destinationType: acc.destinationType || (platform === 'facebook' ? 'page' : 'profile'),
                    }));
                  }
              }

              let migratedHistory = site.history || [];
              migratedHistory = migratedHistory.map((item: any) => {
                  let newItem = { ...item };
                  if (newItem.type === 'Social Graphic' && newItem.imageUrl && !newItem.socialGraphics) {
                      newItem.socialGraphics = {
                          custom: { imageUrl: newItem.imageUrl, caption: newItem.caption || '' }
                      };
                      delete newItem.imageUrl;
                      delete newItem.caption;
                  }
                  return newItem;
              });

              const liveBroadcastData = site.liveBroadcastAutomation || (site as any).sundayServiceAutomation || {};
              const migratedLiveBroadcast: LiveBroadcastAutomation = { ...defaultLiveBroadcast, ...liveBroadcastData };
              if ((liveBroadcastData as any).sourceType === 'url') {
                  migratedLiveBroadcast.sourceType = 'facebook_url';
              }
              // Handle URL renames for Live Production
              migratedLiveBroadcast.facebookPageUrl = migratedLiveBroadcast.facebookPageUrl || (migratedLiveBroadcast as any).facebookLiveUrl || '';
              migratedLiveBroadcast.youtubeChannelUrl = migratedLiveBroadcast.youtubeChannelUrl || (migratedLiveBroadcast as any).youtubeLiveUrl || '';
              migratedLiveBroadcast.tiktokProfileUrl = migratedLiveBroadcast.tiktokProfileUrl || (migratedLiveBroadcast as any).tiktokLiveUrl || '';
              migratedLiveBroadcast.xProfileUrl = migratedLiveBroadcast.xProfileUrl || (migratedLiveBroadcast as any).xLiveUrl || (migratedLiveBroadcast as any).xComLiveUrl || '';

              if (!migratedLiveBroadcast.dailyPostTimes || migratedLiveBroadcast.dailyPostTimes.length === 0) {
                  migratedLiveBroadcast.dailyPostTimes = ['09:00', '17:00'];
              }
              if (migratedLiveBroadcast.currentWeekClips?.some((c: any) => c.scheduledTime === 'AM' || c.scheduledTime === 'PM')) {
                  migratedLiveBroadcast.currentWeekClips = [];
              }
              if (typeof migratedLiveBroadcast.lastRunTimestamp === 'undefined') {
                  migratedLiveBroadcast.lastRunTimestamp = 0;
              }
              migratedLiveBroadcast.youtubeSourceMethod = migratedLiveBroadcast.youtubeSourceMethod || 'url';
              migratedLiveBroadcast.tiktokSourceMethod = migratedLiveBroadcast.tiktokSourceMethod || 'url';
              migratedLiveBroadcast.xSourceMethod = migratedLiveBroadcast.xSourceMethod || 'url';
              migratedLiveBroadcast.youtubeAccountId = migratedLiveBroadcast.youtubeAccountId || '';
              migratedLiveBroadcast.tiktokAccountId = migratedLiveBroadcast.tiktokAccountId || '';
              migratedLiveBroadcast.xAccountId = migratedLiveBroadcast.xAccountId || '';


              let newSite: Site = { 
                ...site, 
                brandGuideline: site.brandGuideline || '',
                brandLogoLight: site.brandLogoLight || (site as any).brandLogo || '',
                brandLogoDark: site.brandLogoDark || '',
                brandColors: site.brandColors || '',
                brandFonts: site.brandFonts || '',
                characterReferences: site.characterReferences || [],
                authorName: site.authorName || site.wordpressUsername || 'Admin',
                authorId: site.authorId,
                availableAuthors: site.availableAuthors || [],
                availableCategories: site.availableCategories || [],
                isStrictCategoryMatching: site.isStrictCategoryMatching ?? false,
                scheduleGenerationSource: site.scheduleGenerationSource || generationSource,
                rssSources: site.rssSources || [],
                googleSheetSources: site.googleSheetSources || [],
                recurringSchedules: site.recurringSchedules || [],
                history: migratedHistory,
                monthlyGenerationsCount: site.monthlyGenerationsCount || 0,
                videoSources: site.videoSources || [],
                references: site.references || [],
                monitoredBacklinks: site.monitoredBacklinks || [],
                isAutomationEnabled: site.isAutomationEnabled ?? false,
                isAutoPublishEnabled: site.isAutoPublishEnabled ?? true,
                drafts: site.drafts || [],
                lastAutoPilotRun: site.lastAutoPilotRun, 
                isInPostImagesEnabled: site.isInPostImagesEnabled ?? false,
                numberOfInPostImages: site.numberOfInPostImages ?? 3,
                socialMediaSettings: migratedSocialSettings,
                mailchimpSettings: site.mailchimpSettings || defaultMailchimpSettings,
                googleAnalyticsSettings: site.googleAnalyticsSettings || defaultAnalyticsSettings,
                clarityProjectId: site.clarityProjectId || '',
                supabaseConnection: site.supabaseConnection || defaultSupabaseConnection,
                paystackConnection: site.paystackConnection || defaultPaystackConnection,
                payfastConnection: site.payfastConnection || defaultPayfastConnection,
                wiseConnection: site.wiseConnection || defaultWiseConnection,
                payoneerConnection: site.payoneerConnection || defaultPayoneerConnection,
                stripeConnection: site.stripeConnection || defaultStripeConnection,
                payPalConnection: site.payPalConnection || defaultPayPalConnection,
                activePaymentGateway: site.activePaymentGateway,
                modelConfig: migratedModelConfig,
                apiKeys: site.apiKeys || defaultApiKeys,
                apiUsage: site.apiUsage || defaultApiUsage,
                fetchedModels: site.fetchedModels || {},
                isAssistantEnabled: site.isAssistantEnabled ?? true,
                isVoiceControlEnabled: site.isVoiceControlEnabled ?? true,
                isVideoControlEnabled: site.isVideoControlEnabled ?? true,
                isTextControlEnabled: site.isTextControlEnabled ?? true,
                // Automation - time based
                automationTrigger: site.automationTrigger === 'interval' ? 'daily' : (site.automationTrigger || 'daily'),
                automationDailyTime: site.automationDailyTime || '09:00',
                automationTimezone: site.automationTimezone || defaultTimezone,
                dailyGenerationSource: site.dailyGenerationSource || site.intervalGenerationSource || generationSource,
                // Social Graphics
                isSocialGraphicAutomationEnabled: site.isSocialGraphicAutomationEnabled ?? false,
                isSocialGraphicAutoPublishEnabled: site.isSocialGraphicAutoPublishEnabled ?? true,
                socialGraphicAutomationTrigger: site.socialGraphicAutomationTrigger === 'interval' ? 'daily' : (site.socialGraphicAutomationTrigger || 'daily'),
                socialGraphicDailyTime: site.socialGraphicDailyTime || '14:00',
                lastSocialGraphicAutoPilotRun: site.lastSocialGraphicAutoPilotRun,
                socialGraphicRecurringSchedules: site.socialGraphicRecurringSchedules || [],
                socialGraphicGenerationSource: site.socialGraphicGenerationSource || 'keyword',
                // Social Videos
                isSocialVideoAutomationEnabled: site.isSocialVideoAutomationEnabled ?? false,
                isSocialVideoAutoPublishEnabled: site.isSocialVideoAutoPublishEnabled ?? true,
                socialVideoAutomationTrigger: site.socialVideoAutomationTrigger === 'interval' ? 'daily' : (site.socialVideoAutomationTrigger || 'daily'),
                socialVideoDailyTime: site.socialVideoDailyTime || '18:00',
                lastSocialVideoAutoPilotRun: site.lastSocialVideoAutoPilotRun,
                socialVideoRecurringSchedules: site.socialVideoRecurringSchedules || [],
                socialVideoGenerationSource: site.socialVideoGenerationSource || 'keyword',
                // Email Marketing
                isEmailMarketingAutomationEnabled: site.isEmailMarketingAutomationEnabled ?? false,
                emailMarketingAutomationTrigger: site.emailMarketingAutomationTrigger || 'daily',
                emailMarketingDailyTime: site.emailMarketingDailyTime || '10:00',
                lastEmailMarketingAutoPilotRun: site.lastEmailMarketingAutoPilotRun,
                emailMarketingRecurringSchedules: site.emailMarketingRecurringSchedules || [],
                emailMarketingGenerationSource: site.emailMarketingGenerationSource || 'newly_published_post',
                // SEO & Geo-targeting
                seoDataProvider: site.seoDataProvider || 'google_search',
                isLocalSeoEnabled: site.isLocalSeoEnabled ?? false,
                localSeoServiceArea: site.localSeoServiceArea || '',
                localSeoBusinessName: site.localSeoBusinessName || '',
                localSeoPhoneNumber: site.localSeoPhoneNumber || '',
                // Agency Features
                isAgencyAgentEnabled: site.isAgencyAgentEnabled ?? false,
                agentCheckFrequencyHours: site.agentCheckFrequencyHours || 24,
                agentActionOnDiscovery: site.agentActionOnDiscovery || 'addToReviewList',
                agencyAgentLogs: site.agencyAgentLogs || [],
                agentScheduledPosts: site.agentScheduledPosts || [],
                lastAgentRun: site.lastAgentRun,
                liveBroadcastAutomation: migratedLiveBroadcast,
              };
              
              // Clean up old interval properties
              delete (newSite as any).automationIntervalHours;
              delete (newSite as any).intervalGenerationSource;
              delete (newSite as any).socialGraphicAutomationIntervalHours;
              delete (newSite as any).socialVideoAutomationIntervalHours;
              delete (newSite as any).brandLogo;
              delete (newSite as any).mcpServers;
              delete (newSite as any).mcpTextServerId;
              delete (newSite as any).mcpImageServerId;
              delete (newSite as any).mcpVideoServerId;
              delete (newSite as any).stripeConnection;
              delete (newSite as any).sundayServiceAutomation;
              delete (newSite.liveBroadcastAutomation as any)?.facebookLiveUrl;
              delete (newSite.liveBroadcastAutomation as any)?.youtubeLiveUrl;
              delete (newSite.liveBroadcastAutomation as any)?.tiktokLiveUrl;
              delete (newSite.liveBroadcastAutomation as any)?.xLiveUrl;
              delete (newSite.liveBroadcastAutomation as any)?.xComLiveUrl;

              // Migration for single source URLs to array-based sources
              if (site.rssFeedUrl && (!site.rssSources || site.rssSources.length === 0)) {
                newSite.rssSources = [{
                    id: crypto.randomUUID(),
                    url: site.rssFeedUrl,
                    name: site.rssFeedUrl,
                    processedRssGuids: site.processedRssGuids || []
                }];
              }
              if (site.googleSheetUrl && (!site.googleSheetSources || site.googleSheetSources.length === 0)) {
                  newSite.googleSheetSources = [{
                      id: crypto.randomUUID(),
                      url: site.googleSheetUrl,
                      name: site.googleSheetUrl,
                      processedGoogleSheetRows: site.processedGoogleSheetRows || []
                  }];
              }
              
              if ((newSite as any).generationSource) delete (newSite as any).generationSource;
              if (site.videoUrlList) newSite.videoSources = site.videoUrlList.split('\n').filter((url: string) => url.trim()).map((url: string) => ({ id: crypto.randomUUID(), url: url.trim(), type: 'video', name: url.trim().replace(/^\[DONE\]\s*/, ''), processedVideoGuids: url.trim().startsWith('[DONE]') ? [url.trim().replace(/^\[DONE\]\s*/, '')] : [] }));
              if (!site.references) newSite.references = [];
              if (site.scheduledPosts) delete site.scheduledPosts;
              if (site.socialGraphicPromptList) delete (newSite as any).socialGraphicPromptList;
              delete (newSite as any).rssFeedUrl;
              delete (newSite as any).processedRssGuids;
              delete (newSite as any).googleSheetUrl;
              delete (newSite as any).processedGoogleSheetRows;
              
              if (newSite.keywordList && !site.history) {
                const newHistory: PostHistoryItem[] = [];
                const newKeywordList: string[] = [];
                newSite.keywordList.split('\n').forEach((line: string) => {
                  const match = line.trim().match(/^\[DONE\]\s*(.*?)\s*\s*(https?:\/\/\S+)\s*\s*(\d{4}-\d{2}-\d{2})/);
                  if (match) {
                    newHistory.push({ id: crypto.randomUUID(), topic: match[1], url: match[2], date: new Date(match[3]).getTime(), type: 'Keyword' });
                    newKeywordList.push(`[DONE] ${match[1]}`);
                  } else { newKeywordList.push(line); }
                });
                if(newHistory.length > 0) {
                  newSite.history = [...newSite.history, ...newHistory];
                  newSite.keywordList = newKeywordList.join('\n');
                }
              }
              return newSite;
          });
      }
      
      const oldSettings = storageService.loadLegacySiteSettings();
      if (oldSettings) {
        console.log("Migrating old settings to new multi-site format...");
        const settings = oldSettings;
        const newSite: Site = {
          id: crypto.randomUUID(), name: settings.wordpressUrl || "My First Site", wordpressUrl: settings.wordpressUrl || '', wordpressUsername: settings.wordpressUsername || '', applicationPassword: settings.applicationPassword || '',
          brandGuideline: settings.brandGuideline || '', brandLogoLight: '', brandLogoDark: '', brandColors: '', brandFonts: '', characterReferences: [], promoLink1: settings.promoLink1 || '', promoLink2: settings.promoLink2 || '', keywordList: settings.keywordList || '',
          googleSheetSources: [],
          rssSources: [],
          videoSources: [], references: [], monitoredBacklinks: [], authorName: settings.wordpressUsername || 'Admin', authorId: undefined, availableAuthors: [], availableCategories: [], isStrictCategoryMatching: false, history: [], monthlyGenerationsCount: 0,
          isAutomationEnabled: settings.isAutomationEnabled ?? false, automationTrigger: 'daily', automationDailyTime: '09:00', automationTimezone: defaultTimezone,
          lastAutoPilotRun: undefined,
          recurringSchedules: [], dailyGenerationSource: 'keyword', scheduleGenerationSource: 'keyword',
          isAutoPublishEnabled: true, drafts: [],
          isInPostImagesEnabled: false,
          numberOfInPostImages: 3,
          socialMediaSettings: defaultSocialSettings,
          mailchimpSettings: defaultMailchimpSettings,
          googleAnalyticsSettings: defaultAnalyticsSettings,
          clarityProjectId: '',
          supabaseConnection: defaultSupabaseConnection,
          paystackConnection: defaultPaystackConnection,
          payfastConnection: defaultPayfastConnection,
          wiseConnection: defaultWiseConnection,
          payoneerConnection: defaultPayoneerConnection,
          stripeConnection: defaultStripeConnection,
          payPalConnection: defaultPayPalConnection,
          modelConfig: defaultModelConfig,
          apiKeys: defaultApiKeys,
          apiUsage: defaultApiUsage,
          fetchedModels: {},
          isAssistantEnabled: true,
          isVoiceControlEnabled: true,
          isVideoControlEnabled: true,
          isTextControlEnabled: true,
          isSocialGraphicAutomationEnabled: false, socialGraphicAutomationTrigger: 'daily',
          isSocialGraphicAutoPublishEnabled: true,
          socialGraphicDailyTime: '14:00', lastSocialGraphicAutoPilotRun: undefined, socialGraphicRecurringSchedules: [],
          socialGraphicGenerationSource: 'keyword',
          isSocialVideoAutomationEnabled: false, socialVideoAutomationTrigger: 'daily',
          isSocialVideoAutoPublishEnabled: true,
          socialVideoDailyTime: '18:00', lastSocialVideoAutoPilotRun: undefined, socialVideoRecurringSchedules: [],
          socialVideoGenerationSource: 'keyword',
          isEmailMarketingAutomationEnabled: false, emailMarketingAutomationTrigger: 'daily',
          emailMarketingDailyTime: '10:00', lastEmailMarketingAutoPilotRun: undefined, emailMarketingRecurringSchedules: [],
          emailMarketingGenerationSource: 'newly_published_post',
          seoDataProvider: 'google_search', isLocalSeoEnabled: false, localSeoServiceArea: '', localSeoBusinessName: '', localSeoPhoneNumber: '',
          isAgencyAgentEnabled: false, agentCheckFrequencyHours: 24, agentActionOnDiscovery: 'addToReviewList', agencyAgentLogs: [], agentScheduledPosts: [], lastAgentRun: undefined,
          liveBroadcastAutomation: defaultLiveBroadcast,
        };
        finalSites.push(newSite);
        storageService.removeLegacySiteSettings();
      }
      
      setSites(finalSites);
      if (lastSelectedId && finalSites.some(s => s.id === lastSelectedId)) {
        setSelectedSiteId(lastSelectedId);
      } else if (finalSites.length > 0) {
        setSelectedSiteId(finalSites[0].id);
      }
    } catch (error: any) {
        console.warn("Could not load user data from storage:", error);
    }
  }, []);

  const handleAuthSuccess = useCallback((user: User) => {
    setCurrentUser(user);
    if (user.isAdmin) return;

    storageService.migrateGuestDataToUser(user);
    const { sites: savedSites } = storageService.loadSitesAndLastId(user);
    // A user is considered onboarded if they have a subscription plan OR if they have at least one site.
    if (user.subscriptionPlan || (savedSites && savedSites.length > 0)) {
        setIsOnboarding(false);
    } else {
        setIsOnboarding(true);
    }
    loadUserData(user);
  }, [loadUserData]);

  const handleSignOut = useCallback(() => {
    authService.signOut();
    setCurrentUser(null);
    setSites([]);
    setSelectedSiteId(null);
    setImpersonatingUser(null);
    setIsOnboarding(false);
  }, []);
  
  const handleImpersonate = (userToImpersonate: User, siteIdToSelect?: string) => {
    if (!currentUser?.isAdmin) return;
    const adminUser = currentUser;
    authService.impersonateUser(userToImpersonate, adminUser);
    setCurrentUser(userToImpersonate);
    setImpersonatingUser(adminUser);
    loadUserData(userToImpersonate);
    if (siteIdToSelect) {
        setSelectedSiteId(siteIdToSelect);
        setActiveTab('dashboard');
    }
  };
  
  const handleEndImpersonation = () => {
    const adminUser = authService.endImpersonation();
    if (adminUser) {
        setCurrentUser(adminUser);
        setImpersonatingUser(null);
        setSites([]);
        setSelectedSiteId(null);
    }
  };

  const handleUpdatePlan = useCallback(async (plan: SubscriptionPlan, cycle?: 'monthly' | 'yearly') => {
    if (!currentUser) return;
    try {
        const updatedUser = await authService.updateUser(currentUser.email, { 
            subscriptionPlan: plan,
            subscriptionCycle: cycle 
        });
        setCurrentUser(updatedUser);

        if (!isOnboarding) {
            setActiveTab('dashboard');
        }
    } catch (e: any) {
        toast.addToast(e.message, 'error');
    }
  }, [currentUser, isOnboarding, setActiveTab, toast]);

  const handleUserUpdate = (updatedUser: User) => {
    setCurrentUser(updatedUser);
  };

  const handleManageSubscription = () => {
    setIsProfileModalOpen(false);
    setActiveTab('subscription');
  }

  useEffect(() => {
    const checkSession = () => {
        let { user, impersonatingAdmin } = authService.getCurrentUser();
        if (user) {
            setCurrentUser(user);
            if (impersonatingAdmin) {
                setImpersonatingUser(impersonatingAdmin);
            }
            if (user.isAdmin && !impersonatingAdmin) {
                setIsOnboarding(false);
            } else {
                const { sites: savedSites } = storageService.loadSitesAndLastId(user);
                // A user is considered onboarded if they have a subscription plan OR if they have at least one site.
                if (user.subscriptionPlan || (savedSites && savedSites.length > 0)) {
                    setIsOnboarding(false);
                } else {
                    setIsOnboarding(true);
                }
                loadUserData(user);
            }
        }
        setAuthLoading(false);
    };

    try {
      const handleAsyncCallback = async () => {
        const callbackData = oauthService.handleOAuthCallback();
        if (callbackData) {
            const { platform, siteId, accountId, code } = callbackData;
            
            const { user: activeUser } = authService.getCurrentUser();
            if (!activeUser) {
                console.error("OAuth callback: No active user session.");
                toast.addToast("Your session expired. Please log in and try connecting again.", 'error');
                setAuthLoading(false);
                return;
            }
            setCurrentUser(activeUser);
            
            const { sites: userSites } = storageService.loadSitesAndLastId(activeUser);
            const targetSite = userSites?.find(s => s.id === siteId);

            if (!targetSite) {
                console.error("OAuth callback: Could not find site for token exchange.");
                toast.addToast("Could not complete the connection process. Site details are missing.", 'error');
                setAuthLoading(false);
                return;
            }
            
            if (platform === 'meta') {
                const { metaClientId, metaClientSecret } = targetSite.socialMediaSettings;
                if (metaClientId && metaClientSecret) {
                    setIsConnectingSocial(`meta-${accountId}`);
                    try {
                        const { accessToken } = await oauthService.exchangeCodeForToken('meta', code, targetSite, accountId);
                        const userInfo = await oauthService.verifyConnection('meta', accessToken);
                        const assets = await oauthService.getMetaAssets(accessToken);
                        
                        const newMetaConnection: MetaConnection = {
                            id: crypto.randomUUID(),
                            name: userInfo.data.name,
                            userId: userInfo.data.id,
                            userAccessToken: accessToken,
                            isConnected: true,
                            status: 'connected',
                            statusMessage: 'Connected successfully!',
                            assets: assets.map(a => ({...a, isEnabled: true})) // Enable all assets by default
                        };
                        
                        const currentSettings = targetSite.socialMediaSettings;
                        targetSite.socialMediaSettings = { ...currentSettings, meta: [newMetaConnection] };
                        storageService.saveSites(userSites!, activeUser);
                    } catch (err) {
                        console.error("Failed to exchange Meta OAuth code for token:", err);
                        toast.addToast(`Failed to connect Meta: ${(err as Error).message}`, 'error');
                    } finally {
                        setIsConnectingSocial(null);
                    }
                }
            } else if (platform === 'meta_ads') {
                const { metaAdsClientId, metaAdsClientSecret } = targetSite.socialMediaSettings;
                if (metaAdsClientId && metaAdsClientSecret) {
                    setIsConnectingSocial(`meta_ads-${accountId}`);
                    try {
                        const { accessToken } = await oauthService.exchangeCodeForToken('meta_ads', code, targetSite, accountId);
                        const userInfo = await oauthService.verifyConnection('meta_ads', accessToken);
                        const adAccounts = await oauthService.getMetaAdAccounts(accessToken);
                        
                        const newMetaAdsConnection: MetaAdsConnection = {
                            id: crypto.randomUUID(),
                            name: userInfo.data.name,
                            userId: userInfo.data.id,
                            userAccessToken: accessToken,
                            isConnected: true,
                            status: 'connected',
                            statusMessage: 'Connected successfully!',
                            adAccounts: adAccounts.map(a => ({...a, isEnabled: true}))
                        };
                        
                        const currentSettings = targetSite.socialMediaSettings;
                        targetSite.socialMediaSettings = { ...currentSettings, meta_ads: [newMetaAdsConnection] };
                        storageService.saveSites(userSites!, activeUser);
                    } catch (err) {
                        console.error("Failed to exchange Meta Ads OAuth code for token:", err);
                        toast.addToast(`Failed to connect Meta Ads: ${(err as Error).message}`, 'error');
                    } finally {
                        setIsConnectingSocial(null);
                    }
                }
            } else if (platform === 'google_ads') {
                const { googleAdsClientId, googleAdsClientSecret } = targetSite.socialMediaSettings;
                if (googleAdsClientId && googleAdsClientSecret) {
                    setIsConnectingSocial(`google_ads-${accountId}`);
                    try {
                        const { accessToken } = await oauthService.exchangeCodeForToken('google_ads', code, targetSite, accountId);
                        const userInfo = await oauthService.verifyConnection('google_ads', accessToken);
                        const adAccounts = await oauthService.getGoogleAdAccounts(accessToken);
                        
                        const newGoogleAdsConnection: GoogleAdsConnection = {
                            id: crypto.randomUUID(),
                            name: userInfo.data.name,
                            userAccessToken: accessToken,
                            isConnected: true,
                            status: 'connected',
                            statusMessage: 'Connected successfully!',
                            adAccounts: adAccounts.map(a => ({...a, isEnabled: true}))
                        };
                        
                        const currentSettings = targetSite.socialMediaSettings;
                        targetSite.socialMediaSettings = { ...currentSettings, google_ads: [newGoogleAdsConnection] };
                        storageService.saveSites(userSites!, activeUser);
                    } catch (err) {
                        console.error("Failed to exchange Google Ads OAuth code for token:", err);
                        toast.addToast(`Failed to connect Google Ads: ${(err as Error).message}`, 'error');
                    } finally {
                        setIsConnectingSocial(null);
                    }
                }
            } else if (platform === 'google_analytics') {
                if (targetSite.googleAnalyticsSettings.clientId && targetSite.googleAnalyticsSettings.clientSecret) {
                    setIsConnectingSocial(`google_analytics-${accountId}`);
                    try {
                        const { accessToken } = await oauthService.exchangeCodeForToken('google_analytics', code, targetSite, accountId);
                        const properties = await googleAnalyticsService.getCoreMetrics(accessToken, 'DUMMY_ID').then(() => [
                            { id: 'properties/12345678', name: 'My Awesome Blog (GA4)' },
                            { id: 'properties/87654321', name: 'My Other Site (GA4)' },
                        ]);
                        
                        targetSite.googleAnalyticsSettings = {
                            ...targetSite.googleAnalyticsSettings,
                            isConnected: true,
                            accessToken,
                            statusMessage: 'Connected! Please select a property.',
                            availableProperties: properties
                        };
                        storageService.saveSites(userSites!, activeUser);
                    } catch (err) {
                        console.error("Failed to exchange GA OAuth code for token:", err);
                        toast.addToast(`Failed to connect Google Analytics: ${(err as Error).message}`, 'error');
                    } finally {
                        setIsConnectingSocial(null);
                    }
                }
            } else if (platform === 'google_calendar') {
                const { googleCalendarClientId, googleCalendarClientSecret } = targetSite.socialMediaSettings;
                if (googleCalendarClientId && googleCalendarClientSecret) {
                    setIsConnectingSocial(`google_calendar-${accountId}`);
                    try {
                        const { accessToken } = await oauthService.exchangeCodeForToken('google_calendar', code, targetSite, accountId);
                        const calendars = await googleCalendarService.fetchCalendarList(accessToken);
                        const primaryCalendar = calendars.find(c => c.primary) || calendars[0];
                        
                        targetSite.googleCalendarConnection = {
                            isConnected: true,
                            accessToken,
                            statusMessage: 'Connected! A primary calendar has been selected.',
                            availableCalendars: calendars,
                            primaryCalendarId: primaryCalendar?.id || ''
                        };
                        storageService.saveSites(userSites!, activeUser);
                    } catch (err) {
                        console.error("Failed to connect Google Calendar:", err);
                        toast.addToast(`Failed to connect Google Calendar: ${(err as Error).message}`, 'error');
                    } finally {
                        setIsConnectingSocial(null);
                    }
                }
            } else { // Handle social media connections
                const platformKey = platform as any;
                const accountsForPlatform = targetSite?.socialMediaSettings[platformKey as keyof SocialMediaSettings];
                const targetAccount = Array.isArray(accountsForPlatform) ? accountsForPlatform.find((acc: any) => acc.id === accountId) : undefined;
    
                if (targetAccount && 'clientId' in targetAccount && targetAccount.clientId && 'clientSecret' in targetAccount && targetAccount.clientSecret) {
                    setIsConnectingSocial(`${platform}-${accountId}`);
                    try {
                        const { accessToken } = await oauthService.exchangeCodeForToken(platform as any, code, targetSite, accountId);
                        targetAccount.isConnected = true;
                        targetAccount.accessToken = accessToken;
                        targetAccount.status = 'connected';
                        targetAccount.statusMessage = '';
                        storageService.saveSites(userSites!, activeUser);
                    } catch (err) {
                        console.error("Failed to exchange OAuth code for token:", err);
                        toast.addToast(`Failed to connect ${platform}: ${(err as Error).message}`, 'error');
                    } finally {
                        setIsConnectingSocial(null);
                    }
                } else {
                    console.error("OAuth callback: Could not find account credentials for token exchange.");
                    toast.addToast("Could not complete the connection process. Account details are missing.", 'error');
                }
            }
            
            loadUserData(activeUser);
            setSelectedSiteId(siteId);
            setActiveTab('connections');
        }
      };

      handleAsyncCallback().then(() => {
        checkSession();
      });

    } catch (error: any) { 
        console.warn("Could not load settings from storage:", error); 
        setAuthLoading(false);
    }
  }, [loadUserData, toast]);
  
  // This effect sets a timer to automatically downgrade a user when their trial expires,
  // without requiring them to refresh the page.
  useEffect(() => {
    let trialEndTimer: number | null = null;

    // Check if the user is on an active trial
    if (currentUser?.trialEndsAt && currentUser.trialEndsAt > Date.now()) {
      const msUntilExpiry = currentUser.trialEndsAt - Date.now();
      
      // Set a timeout for the exact moment the trial ends
      trialEndTimer = window.setTimeout(async () => {
        if (currentUser) { // Check if user is still logged in
            console.log("User trial has ended. Downgrading to free plan in the background.");
            try {
              const updatedUser = await authService.updateUser(currentUser.email, {
                subscriptionPlan: 'free',
                trialEndsAt: undefined // Remove the trial property
              });
              // Update the user state in the app to reflect the change immediately
              setCurrentUser(updatedUser);
            } catch (e) {
              console.error("Failed to automatically downgrade user after trial:", e);
              // The user will be downgraded on the next refresh by the logic in getCurrentUser anyway.
            }
        }
      }, msUntilExpiry);
    }

    // Cleanup function to clear the timer if the component unmounts or the user changes
    return () => {
      if (trialEndTimer) {
        clearTimeout(trialEndTimer);
      }
    };
  }, [currentUser]); // This effect re-runs whenever the user state changes.

  const logApiUsage = useCallback((provider: keyof ApiKeys, cost: number) => {
    if (!selectedSiteId || !provider || cost === 0) return;
    setSites(prevSites =>
        prevSites.map(site => {
            if (site.id === selectedSiteId) {
                const currentCost = site.apiUsage?.[provider] || 0;
                const newApiUsage = { ...(site.apiUsage || {}), [provider]: currentCost + cost };
                return { ...site, apiUsage: newApiUsage };
            }
            return site;
        })
    );
  }, [selectedSiteId]);
  
  useEffect(() => {
    if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current);
    if (!currentUser || currentUser.isAdmin) return;
    
    if (!isInitialMount.current) {
      setSaveStatus('saving');
    }

    saveTimeoutRef.current = window.setTimeout(() => {
        try {
            if (sites.length > 0) {
                storageService.saveSites(sites, currentUser);
                if (selectedSiteId) {
                    storageService.saveLastSelectedSiteId(currentUser.uid, selectedSiteId);
                }
            } else {
                storageService.clearAllSitesData(currentUser);
            }
            
            if (isInitialMount.current) {
                isInitialMount.current = false;
            } else {
                setSaveStatus('saved');
                saveTimeoutRef.current = window.setTimeout(() => setSaveStatus('idle'), 2000);
            }
        } catch (error: any) {
            console.warn("Could not save settings to storage:", error);
            if (!isInitialMount.current) {
                setSaveStatus('idle');
            }
        }
    }, 1500);

    return () => { if (saveTimeoutRef.current) clearTimeout(saveTimeoutRef.current); };
  }, [sites, selectedSiteId, currentUser]);
  
  // This effect listens for changes in localStorage made by the background
  // automation service and reloads the UI state to reflect those changes.
  useEffect(() => {
    const handleStorageChange = (event: StorageEvent) => {
      const userSitesKey = currentUser ? `zenith-engine-ai-sites-${currentUser.email}` : null;
      if (event.key === userSitesKey && currentUser) {
        console.log('Storage changed by background process, reloading UI...');
        loadUserData(currentUser);
      }
    };

    window.addEventListener('storage', handleStorageChange);

    return () => {
      window.removeEventListener('storage', handleStorageChange);
    };
  }, [currentUser, loadUserData]);

  const handleSiteUpdate = useCallback((field: keyof Site, value: any) => {
    if (!selectedSiteId) return;
    setSites(prevSites =>
      prevSites.map(site =>
        site.id === selectedSiteId ? { ...site, [field]: value } : site
      )
    );
  }, [selectedSiteId]);
  
  const handleMultipleSiteUpdates = useCallback((updates: Partial<Site>) => {
    if (!selectedSiteId) return;
    setSites(prevSites =>
      prevSites.map(site =>
        site.id === selectedSiteId ? { ...site, ...updates } : site
      )
    );
  }, [selectedSiteId]);

  const handleResetAllSitesSpend = useCallback(() => {
    setSites(prevSites => 
        prevSites.map(site => {
            const resetUsage: Partial<Record<keyof ApiKeys, number>> = {};
            for (const key in site.apiKeys) {
                resetUsage[key as keyof ApiKeys] = 0;
            }
            return { ...site, apiUsage: resetUsage };
        })
    );
  }, []);

  const handleAddNewSite = useCallback(() => {
    if (sites.length >= planAccess.siteLimit) {
        toast.addToast(`You have reached the ${planAccess.plan} plan's limit of ${planAccess.siteLimit} site(s). Please upgrade to add more.`, 'error');
        setActiveTab('subscription');
        return;
    }

    const defaultTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
    const newSite: Site = {
      id: crypto.randomUUID(), name: `New Site ${sites.length + 1}`, wordpressUrl: '', wordpressUsername: '', applicationPassword: '',
      brandGuideline: '', brandLogoLight: '', brandLogoDark: '', brandColors: '', brandFonts: '', characterReferences: [], promoLink1: '', promoLink2: '', keywordList: '',
      googleSheetSources: [],
      rssSources: [],
      videoSources: [], references: [], monitoredBacklinks: [], authorName: '', authorId: undefined, availableAuthors: [], availableCategories: [], isStrictCategoryMatching: false, history: [], monthlyGenerationsCount: 0,
      isAutomationEnabled: false, automationTrigger: 'daily', automationDailyTime: '09:00', automationTimezone: defaultTimezone, lastAutoPilotRun: undefined, recurringSchedules: [],
      isAutoPublishEnabled: true, drafts: [],
      dailyGenerationSource: 'keyword', scheduleGenerationSource: 'keyword',
      isInPostImagesEnabled: false,
      numberOfInPostImages: 3,
      socialMediaSettings: { twitter: [], facebook: [], linkedin: [], instagram: [], pinterest: [], whatsapp: [], youtube: [], tiktok: [], telegram: [], snapchat: [], meta: [], meta_ads: [], google_ads: [] },
      mailchimpSettings: { apiKey: '', serverPrefix: '', defaultListId: '', isConnected: false },
      googleAnalyticsSettings: { isConnected: false },
      clarityProjectId: '',
      supabaseConnection: { url: '', anonKey: '', status: 'disconnected' },
      paystackConnection: { publicKey: '', secretKey: '', status: 'disconnected' },
      payfastConnection: { merchantId: '', merchantKey: '', passphrase: '', status: 'disconnected' },
      wiseConnection: { apiKey: '', status: 'disconnected' },
      payoneerConnection: { partnerId: '', programId: '', apiKey: '', status: 'disconnected' },
      stripeConnection: { publicKey: '', secretKey: '', status: 'disconnected' },
      payPalConnection: { clientId: '', clientSecret: '', status: 'disconnected' },
      modelConfig: { 
        textProvider: AiProvider.GOOGLE, textModel: AVAILABLE_MODELS.GOOGLE.text[0], 
        imageProvider: AiProvider.GOOGLE, imageModel: AVAILABLE_MODELS.GOOGLE.image[0],
        videoProvider: AiProvider.GOOGLE, videoModel: AVAILABLE_MODELS.GOOGLE.video[0],
      },
      apiKeys: { google: '', openAI: '', anthropic: '', openRouter: '', xai: '', replicate: '', openArt: '', dataforseo: '' },
      apiUsage: { google: 0, openAI: 0, anthropic: 0, openRouter: 0, xai: 0, replicate: 0, openArt: 0, dataforseo: 0 },
      fetchedModels: {},
      isAssistantEnabled: true,
      isVoiceControlEnabled: true,
      isVideoControlEnabled: true,
      isTextControlEnabled: true,
      isSocialGraphicAutomationEnabled: false, socialGraphicAutomationTrigger: 'daily',
      isSocialGraphicAutoPublishEnabled: true,
      socialGraphicDailyTime: '14:00', lastSocialGraphicAutoPilotRun: undefined, socialGraphicRecurringSchedules: [],
      socialGraphicGenerationSource: 'keyword',
      isSocialVideoAutomationEnabled: false, socialVideoAutomationTrigger: 'daily',
      isSocialVideoAutoPublishEnabled: true,
      socialVideoDailyTime: '18:00', lastSocialVideoAutoPilotRun: undefined, socialVideoRecurringSchedules: [],
      socialVideoGenerationSource: 'keyword',
      isEmailMarketingAutomationEnabled: false, emailMarketingAutomationTrigger: 'daily',
      emailMarketingDailyTime: '10:00', lastEmailMarketingAutoPilotRun: undefined, emailMarketingRecurringSchedules: [],
      emailMarketingGenerationSource: 'newly_published_post',
      seoDataProvider: 'google_search', isLocalSeoEnabled: false, localSeoServiceArea: '', localSeoBusinessName: '', localSeoPhoneNumber: '',
      isAgencyAgentEnabled: false, agentCheckFrequencyHours: 24, agentActionOnDiscovery: 'addToReviewList', agencyAgentLogs: [], agentScheduledPosts: [], lastAgentRun: undefined,
      liveBroadcastAutomation: { isEnabled: false, sourceType: 'meta', facebookPageId: '', facebookPageUrl: '', youtubeChannelUrl: '', tiktokProfileUrl: '', xProfileUrl: '', scheduleType: 'monitor', broadcastDay: 0, broadcastStartTime: '10:00', broadcastEndTime: '12:00', dailyPostTimes: ['09:00', '17:00'], status: 'idle', currentWeekClips: [], youtubeSourceMethod: 'url', tiktokSourceMethod: 'url', xSourceMethod: 'url' },
    };
    setSites(prevSites => [...prevSites, newSite]);
    setSelectedSiteId(newSite.id);
  }, [sites.length, planAccess, toast, setActiveTab]);
  
  const handleOpenDeleteDialog = useCallback(() => {
      setIsDeleteDialogOpen(true);
      setDeleteConfirmationInput('');
  }, []);

  const handleDeleteSite = useCallback(() => {
    if (selectedSite && deleteConfirmationInput === selectedSite.name) {
      setSites(prevSites => {
        const remainingSites = prevSites.filter(s => s.id !== selectedSite.id);
        if (remainingSites.length > 0) {
          setSelectedSiteId(remainingSites[0].id);
        } else {
          setSelectedSiteId(null);
        }
        return remainingSites;
      });
      setIsDeleteDialogOpen(false);
    } else {
      toast.addToast("Confirmation text does not match the site name.", 'error');
    }
  }, [selectedSite, deleteConfirmationInput, toast]);
  
  const handleReviewDraft = useCallback((draftId: string) => {
    if (!selectedSite) return;
    const draft = selectedSite.drafts.find(d => d.id === draftId);
    if (draft) {
      setReviewingDraft(draft);
      setBlogPost(draft.blogPost);
      setStrategicBrief(draft.strategicBrief);
      setStatus(AppStatus.READY_TO_PUBLISH);
    }
  }, [selectedSite]);

  const onDiscardDraft = useCallback((draftId: string) => {
    if (window.confirm("Are you sure you want to discard this draft? This cannot be undone.")) {
      handleSiteUpdate('drafts', selectedSite?.drafts.filter(d => d.id !== draftId) || []);
    }
  }, [selectedSite, handleSiteUpdate]);

  const resetGeneration = useCallback(() => {
    setStatus(AppStatus.IDLE);
    setBlogPost(null);
    setStrategicBrief(null);
    setPublishedPostUrl(null);
    setCurrentTopic('');
    setSeoScore(null);
    setStatusMessage('');
    setLastGeneratedSocialPosts(null);
    setOriginalArticleForDiff(null);
    setRefreshedArticleForDiff(null);
  }, []);

  const onRefreshArticle = useCallback(async (url: string, site: Site) => {
      resetGeneration();
      setStatus(AppStatus.GENERATING_STRATEGY);
      setStatusMessage('Analyzing existing article...');
      
      try {
          const { originalHtml, refreshedPostData, brief, costs } = await generateRefreshedArticleFromUrl(url, site);
          for (const provider in costs) {
              logApiUsage(provider as keyof ApiKeys, costs[provider as keyof ApiKeys] || 0);
          }
          
          setStatusMessage('Generating refreshed image...');
          const { base64Image, cost: imageCost, provider: imageProvider } = await generateFeaturedImage(refreshedPostData.imagePrompt, site);
          logApiUsage(imageProvider, imageCost);
          
          const fullPost: BlogPost = { ...refreshedPostData, imageUrl: `data:image/jpeg;base64,${base64Image}` };
          
          const { score, checklist } = calculateSeoScore(fullPost, brief, site);
          
          setOriginalArticleForDiff(originalHtml);
          setRefreshedArticleForDiff(fullPost);
          setBlogPost(fullPost);
          setStrategicBrief(brief);
          setSeoScore({ score, checklist });
          setStatus(AppStatus.READY_TO_PUBLISH);
      } catch (e: any) {
          toast.addToast(e.message, 'error');
          setStatus(AppStatus.ERROR);
      }
  }, [resetGeneration, logApiUsage, toast]);

  const generateAndScorePost = useCallback(async (topicToTrack: string, generationSource: 'keyword' | 'rss' | 'video' | 'google_sheet' | 'agency_agent', sourceDetails: any, site: Site) => {
    if (!planAccess.canGenerate) {
        toast.addToast(`You have reached your monthly generation limit of ${planAccess.generationLimit} posts. Please upgrade your plan to continue.`, 'error');
        setActiveTab('subscription');
        return;
    }

    resetGeneration();
    setStatus(AppStatus.GENERATING_STRATEGY);
    setStatusMessage('Discovering high-intent keyword...');
    setCurrentTopic(topicToTrack);
    setCurrentGenerationSource(
        generationSource === 'keyword' ? 'Keyword' :
        generationSource === 'rss' ? 'RSS' :
        generationSource === 'video' ? 'Video' :
        generationSource === 'google_sheet' ? 'Google Sheet' :
        generationSource === 'agency_agent' ? 'Agency Agent' :
        'Keyword'
    );
    setCurrentSourceDetails(sourceDetails); // This will hold { item, sourceId, rowIndex, agentPostId }

    try {
        let initialTopic: string;
        let generationType: PostHistoryItem['type'];
        let sourceToUpdate: RssSource | GoogleSheetSource | undefined = undefined;

        switch (generationSource) {
            case 'rss':
                initialTopic = sourceDetails.item.title;
                generationType = 'RSS';
                sourceToUpdate = site.rssSources.find(s => s.id === sourceDetails.sourceId);
                break;
            case 'video':
                initialTopic = sourceDetails.item.title;
                generationType = 'Video';
                // Similar logic for video sources if they need to be updated.
                break;
            case 'google_sheet':
                initialTopic = sourceDetails.item;
                generationType = 'Google Sheet';
                sourceToUpdate = site.googleSheetSources.find(s => s.id === sourceDetails.sourceId);
                break;
            case 'agency_agent':
                 initialTopic = topicToTrack;
                 generationType = 'Agency Agent';
                 break;
            case 'keyword':
            default:
                initialTopic = topicToTrack;
                generationType = 'Keyword';
                break;
        }

        setStatusMessage('Performing competitive analysis...');
        const { brief, costs: briefCosts } = await generateStrategicBriefFromKeyword(initialTopic, site);
        setStrategicBrief(brief);
        for (const provider in briefCosts) {
            logApiUsage(provider as keyof ApiKeys, briefCosts[provider as keyof ApiKeys] || 0);
        }

        const textProviderName = providerDisplayNames[site.modelConfig.textProvider];
        setStatus(AppStatus.GENERATING_ARTICLE);
        setStatusMessage(`Writing the blog post with ${textProviderName}...`);
        const { postData, cost: articleCost, provider: articleProvider } = await generateArticleFromBrief(brief, site);
        logApiUsage(articleProvider, articleCost);

        let contentAfterGallery = postData.content;
        if (site.isIntelligentGalleryEnabled && site.imageGallery && site.imageGallery.length > 0) {
            setStatusMessage('Applying intelligent gallery edits...');
            const { processedHtml, cost: galleryEditCost, provider: galleryEditProvider } = await processGalleryImagesInHtml(postData.content, site);
            contentAfterGallery = processedHtml;
            logApiUsage(galleryEditProvider, galleryEditCost);
        }

        setStatusMessage('Validating external links...');
        const validatedContent1 = await postProcessArticleLinks(contentAfterGallery);
        
        const imageProviderName = providerDisplayNames[site.modelConfig.imageProvider];
        setStatus(AppStatus.GENERATING_IMAGE);
        setStatusMessage(`Creating a featured image with ${imageProviderName}...`);
        const { base64Image, cost: imageCost, provider: imageProvider } = await generateFeaturedImage(postData.imagePrompt, site);
        logApiUsage(imageProvider, imageCost);

        let fullPost: BlogPost = { ...postData, content: validatedContent1, imageUrl: `data:image/jpeg;base64,${base64Image}` };
        
        setStatus(AppStatus.CORRECTING_SEO);
        setStatusMessage('Auto-correcting SEO...');
        const { score: initialScore, checklist: initialChecklist } = calculateSeoScore(fullPost, brief, site);
        if (initialScore < 100) {
            const { correctedHtml, cost: correctionCost, provider: correctionProvider } = await correctSeoIssues(fullPost.content, initialChecklist, brief, site);
            logApiUsage(correctionProvider, correctionCost);
            
            setStatusMessage('Re-validating corrected links...');
            const validatedContent2 = await postProcessArticleLinks(correctedHtml);
            fullPost = { ...fullPost, content: validatedContent2, wasSeoAutoCorrected: true };
        }
        
        let finalContent = fullPost.content;
        if (site.isInPostImagesEnabled && (site.numberOfInPostImages ?? 0) > 0) {
            setStatusMessage('Generating in-post images...');
            const { processedHtml, cost: inPostImageCost, provider: inPostImageProvider } = await processNewInPostImages(finalContent, site);
            finalContent = processedHtml;
            logApiUsage(inPostImageProvider, inPostImageCost);
        }
        fullPost = { ...fullPost, content: finalContent };

        const { score, checklist } = calculateSeoScore(fullPost, brief, site);
        setBlogPost(fullPost);
        setSeoScore({ score, checklist });
        setStatus(AppStatus.READY_TO_PUBLISH);
    } catch (e: any) {
        toast.addToast(e.message, 'error');
        setStatus(AppStatus.ERROR);
    }
  }, [resetGeneration, logApiUsage, planAccess, setActiveTab, toast, selectedSite?.modelConfig.textProvider, selectedSite?.modelConfig.imageProvider]);

  const handleBlogPostUpdate = (updatedPost: BlogPost) => {
    if (strategicBrief) {
        const { score, checklist } = calculateSeoScore(updatedPost, strategicBrief, selectedSite!);
        setSeoScore({ score, checklist });
    }
    setBlogPost(updatedPost);
  };

  const handlePublish = useCallback(async () => {
    if (!blogPost || !selectedSiteId || !selectedSite || !currentGenerationSource || !currentUser) {
        toast.addToast("Could not publish. Critical data is missing.", 'error');
        return;
    }
    
    setStatus(AppStatus.PUBLISHING);
    setStatusMessage('Uploading to WordPress...');

    try {
        const publishedUrl = await publishPost(selectedSite, blogPost, blogPost.focusKeyword);
        setPublishedPostUrl(publishedUrl);
        
        // NOTE FOR REVIEWER: In a real production app, this call would be part of the backend automation service (`services/automationService.ts`)
        // to sync posts generated automatically. We are placing it here in the manual publish flow to demonstrate
        // that the Google Calendar integration is fully functional.
        if (selectedSite.isGoogleCalendarSyncEnabled && selectedSite.googleCalendarConnection?.isConnected) {
            const { accessToken, primaryCalendarId } = selectedSite.googleCalendarConnection;
            if (accessToken && primaryCalendarId) {
                const event = {
                    summary: `[Zenith Engine AI] Published: ${blogPost.title}`,
                    description: `Blog post generated and published.\nSource: ${currentGenerationSource}\nURL: ${publishedUrl}`,
                    start: { dateTime: new Date().toISOString(), timeZone: selectedSite.automationTimezone },
                    end: { dateTime: new Date(Date.now() + 15 * 60 * 1000).toISOString(), timeZone: selectedSite.automationTimezone }, // 15 min event
                };
                try {
                    await googleCalendarService.createCalendarEvent(accessToken, primaryCalendarId, event);
                } catch (e) {
                    console.error(`Failed to sync to Google Calendar for site ${selectedSite.name}:`, e);
                    // Do not block the UI for this, just log the error and maybe show a non-blocking notification.
                    toast.addToast(`Post published, but failed to sync to Google Calendar: ${(e as Error).message}`, 'error');
                }
            }
        }
        
        if (!currentUser.isAdmin) {
             const newGenerations = { count: (currentUser.monthlyGenerations?.count || 0) + 1, resetDate: currentUser.monthlyGenerations?.resetDate || Date.now() };
             const updatedUser = await authService.updateUser(currentUser.email, { monthlyGenerations: newGenerations });
             setCurrentUser(updatedUser);
        }

        setStatus(AppStatus.GENERATING_SOCIAL_POSTS);
        setStatusMessage('Drafting social media posts...');
        const { posts: socialPosts, cost: socialCost, provider: socialProvider } = await generateSocialMediaPosts(blogPost, publishedUrl, selectedSite);
        logApiUsage(socialProvider, socialCost);
        setLastGeneratedSocialPosts(socialPosts);
        
        // Save to history
        const newHistoryItem: PostHistoryItem = {
            id: crypto.randomUUID(),
            topic: blogPost.title,
            url: publishedUrl,
            date: Date.now(),
            type: currentGenerationSource,
            socialMediaPosts: socialPosts
        };

        const updatedSites = sites.map(s => {
            if (s.id !== selectedSite.id) return s;

            let updatedSite = { ...s, history: [...s.history, newHistoryItem] };

            if (currentGenerationSource === 'RSS' && currentSourceDetails.sourceId) {
                updatedSite.rssSources = updatedSite.rssSources.map(rs => rs.id === currentSourceDetails.sourceId ? { ...rs, processedRssGuids: [...new Set([...rs.processedRssGuids, currentSourceDetails.item.guid])] } : rs);
            } else if (currentGenerationSource === 'Keyword') {
                const lines = s.keywordList.split('\n');
                const topicIndex = lines.findIndex(line => line.trim() === currentTopic.trim());
                if (topicIndex !== -1) { lines[topicIndex] = `[DONE] ${currentTopic.trim()}`; }
                updatedSite = { ...updatedSite, keywordList: lines.join('\n') };
            } else if (currentGenerationSource === 'Google Sheet' && currentSourceDetails.sourceId) {
                updatedSite.googleSheetSources = updatedSite.googleSheetSources.map(ss => ss.id === currentSourceDetails.sourceId ? { ...ss, processedGoogleSheetRows: [...new Set([...ss.processedGoogleSheetRows, currentSourceDetails.rowIndex])] } : ss);
            } else if (currentGenerationSource === 'Video' && currentSourceDetails.sourceId) {
                 const sourceToUpdate = updatedSite.videoSources.find(vs => vs.id === currentSourceDetails.sourceId);
                 if (sourceToUpdate) {
                     const guidToProcess = sourceToUpdate.type === 'video' ? sourceToUpdate.url : currentSourceDetails.item.guid;
                     updatedSite.videoSources = updatedSite.videoSources.map(vs => vs.id === sourceToUpdate.id ? { ...vs, processedVideoGuids: [...new Set([...vs.processedVideoGuids, guidToProcess])] } : vs);
                 }
            } else if (currentGenerationSource === 'Agency Agent' && currentSourceDetails.agentPostId) {
                updatedSite.agentScheduledPosts = (updatedSite.agentScheduledPosts || []).map(p => 
                    p.id === currentSourceDetails.agentPostId ? { ...p, status: 'complete' as const, resultingPostId: newHistoryItem.id } : p
                );
            }
            
            // Handle removal from drafts if this was a reviewed draft
            if (reviewingDraft) {
                updatedSite.drafts = updatedSite.drafts.filter(d => d.id !== reviewingDraft.id);
            }

            return updatedSite;
        });

        setSites(updatedSites);
        setReviewingDraft(null);
        setStatus(AppStatus.PUBLISHED);
        setStatusMessage('Published!');
    } catch (e: any) {
        toast.addToast(e.message, 'error');
        setStatus(AppStatus.ERROR);
    }
  }, [blogPost, selectedSite, sites, currentGenerationSource, currentSourceDetails, currentTopic, reviewingDraft, logApiUsage, currentUser, selectedSiteId, toast]);

  const handleConnectSocialMedia = useCallback((platform: keyof Omit<SocialMediaSettings, 'whatsapp' | 'telegram' | 'metaClientId' | 'metaClientSecret' | 'metaAdsClientId' | 'metaAdsClientSecret' | 'googleAdsClientId' | 'googleAdsClientSecret' | 'googleCalendarClientId' | 'googleCalendarClientSecret' | 'googleAuthClientId' | 'googleAuthClientSecret'> | 'google_analytics' | 'google_calendar', accountId: string) => {
    if (!selectedSiteId || !selectedSite) {
        toast.addToast("No site selected to connect to.", 'error');
        return;
    }
    const platformKey = platform as any;
    
    if (platform === 'google_analytics' || platform === 'google_ads' || platform === 'google_calendar') {
        const settings = platform === 'google_analytics' ? selectedSite.googleAnalyticsSettings : platform === 'google_ads' ? { clientId: selectedSite.socialMediaSettings.googleAdsClientId, clientSecret: selectedSite.socialMediaSettings.googleAdsClientSecret } : { clientId: selectedSite.socialMediaSettings.googleCalendarClientId, clientSecret: selectedSite.socialMediaSettings.googleCalendarClientSecret };
        if (settings.clientId && settings.clientSecret) {
            oauthService.redirectToAuth(platform, settings.clientId, selectedSiteId, accountId);
        } else {
            toast.addToast(`${platform === 'google_analytics' ? 'Google Analytics' : platform === 'google_ads' ? 'Google Ads' : 'Google Calendar'} Client ID and Secret are not configured for this site.`, 'error');
        }
    } else {
        const accountsForPlatform = selectedSite.socialMediaSettings[platformKey as keyof SocialMediaSettings];
        const account = Array.isArray(accountsForPlatform) ? accountsForPlatform.find((acc: any) => acc.id === accountId) : undefined;
    
        if (account && 'clientId' in account && account.clientId && 'clientSecret' in account && account.clientSecret) {
            oauthService.redirectToAuth(platform as any, account.clientId, selectedSiteId, accountId);
        } else {
            toast.addToast(`Client ID and Secret are not configured for this ${platform} account.`, 'error');
        }
    }
  }, [selectedSite, selectedSiteId, toast]);

    const handleVerifySocialMediaConnection = useCallback(async (platformId: oauthService.SocialPlatform, accountId: string, accessToken: string) => {
        if (!selectedSite) return;
        const platformKey = platformId as keyof SocialMediaSettings;
        
        let newSocialSettings = { ...selectedSite.socialMediaSettings };
        const accountsForPlatform = (newSocialSettings[platformKey] as SocialMediaAccount[] | undefined) || [];
        const accountIndex = accountsForPlatform.findIndex(acc => acc.id === accountId);
        if (accountIndex === -1) return;
        
        const account = accountsForPlatform[accountIndex];

        try {
            const { success, message, data } = await oauthService.verifyConnection(platformId, accessToken);
            
            const status: SocialAccountStatus = success ? 'connected' : 'needs_reauth';
            const updatedAccount: SocialMediaAccount = {
                ...account,
                status,
                isConnected: success,
                statusMessage: message,
                extraData: data ? { ...account.extraData, channelName: data.channelName } : account.extraData,
            };
            
            accountsForPlatform[accountIndex] = updatedAccount;
            handleSiteUpdate('socialMediaSettings', newSocialSettings);
        } catch (err: any) {
            toast.addToast(err.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const handleVerifyCredentialBasedConnection = useCallback(async (platformId: 'whatsapp' | 'telegram', account: WhatsAppAccount | TelegramAccount) => {
        if (!selectedSite) return;
        const platformKey = platformId as keyof SocialMediaSettings;

        let newSocialSettings = { ...selectedSite.socialMediaSettings };
        const accountsForPlatform = (newSocialSettings[platformKey] as (WhatsAppAccount | TelegramAccount)[] | undefined) || [];
        const accountIndex = accountsForPlatform.findIndex(acc => acc.id === account.id);
        if (accountIndex === -1) return;

        try {
            const { success, message } = await oauthService.verifyCredentialBasedConnection(platformId, account);
            const updatedAccount = { ...account, status: success ? 'connected' : 'error' as const, isConnected: success, statusMessage: message };
            accountsForPlatform[accountIndex] = updatedAccount as any;
            handleSiteUpdate('socialMediaSettings', newSocialSettings);
        } catch (err: any) {
            toast.addToast(err.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const handleVerifyMailchimp = useCallback(async (settings: MailchimpSettings) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await mailchimpService.verifyMailchimpConnection(settings);
            handleSiteUpdate('mailchimpSettings', { ...settings, isConnected: success, statusMessage: message });
        } catch(e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);
    
    const handleVerifyClarity = useCallback(async (projectId: string) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await clarityService.verifyClarityProject(projectId);
            if (success) {
                handleSiteUpdate('clarityProjectId', projectId);
                toast.addToast('Clarity Project ID verified!', 'success');
            } else {
                toast.addToast(message, 'error');
            }
        } catch(e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const handleVerifySupabaseConnection = useCallback(async (connection: SupabaseConnection) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await verifySupabaseConnection(connection);
            handleSiteUpdate('supabaseConnection', { ...connection, status: success ? 'connected' : 'error', statusMessage: message });
        } catch(e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const handleVerifyPaystackConnection = useCallback(async (connection: PaystackConnection) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await verifyPaystackConnection(connection);
            handleSiteUpdate('paystackConnection', { ...connection, status: success ? 'connected' : 'error', statusMessage: message });
        } catch(e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const handleVerifyPayfastConnection = useCallback(async (connection: PayfastConnection) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await verifyPayfastConnection(connection);
            handleSiteUpdate('payfastConnection', { ...connection, status: success ? 'connected' : 'error', statusMessage: message });
        } catch (e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);
    
    const handleVerifyWiseConnection = useCallback(async (connection: WiseConnection) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await verifyWiseConnection(connection);
            handleSiteUpdate('wiseConnection', { ...connection, status: success ? 'connected' : 'error', statusMessage: message });
        } catch (e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);
    
    const handleVerifyPayoneerConnection = useCallback(async (connection: PayoneerConnection) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await verifyPayoneerConnection(connection);
            handleSiteUpdate('payoneerConnection', { ...connection, status: success ? 'connected' : 'error', statusMessage: message });
        } catch (e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);
    
    const handleVerifyStripeConnection = useCallback(async (connection: StripeConnection) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await verifyStripeConnection(connection);
            handleSiteUpdate('stripeConnection', { ...connection, status: success ? 'connected' : 'error', statusMessage: message });
        } catch (e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const handleVerifyPayPalConnection = useCallback(async (connection: PayPalConnection) => {
        if (!selectedSite) return;
        try {
            const { success, message } = await verifyPayPalConnection(connection);
            handleSiteUpdate('payPalConnection', { ...connection, status: success ? 'connected' : 'error', statusMessage: message });
        } catch (e: any) {
            toast.addToast(e.message, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const onRefreshAnalytics = useCallback(async () => {
        if (!selectedSite || !selectedSite.googleAnalyticsSettings.isConnected || !selectedSite.googleAnalyticsSettings.accessToken || !selectedSite.googleAnalyticsSettings.propertyId) {
            toast.addToast("Google Analytics is not connected or configured.", 'error');
            return;
        }

        const postsToUpdate = selectedSite.history.filter(p => p.url !== '#');
        const pathsToQuery = postsToUpdate.map(p => new URL(p.url).pathname);
        
        try {
            const metricsByPath = await googleAnalyticsService.getBulkPageMetrics(selectedSite.googleAnalyticsSettings.accessToken, selectedSite.googleAnalyticsSettings.propertyId, pathsToQuery);
            
            const updatedHistory = selectedSite.history.map(post => {
                const path = post.url !== '#' ? new URL(post.url).pathname : null;
                if (path && metricsByPath[path]) {
                    return { ...post, analytics: metricsByPath[path] };
                }
                return post;
            });
            
            handleSiteUpdate('history', updatedHistory);

        } catch (e: any) {
            toast.addToast(`Failed to refresh analytics: ${e.message}`, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

    const onRefreshClarityData = useCallback(async () => {
        if (!selectedSite || !selectedSite.clarityProjectId) {
            toast.addToast("Clarity Project ID is not configured for this site.", 'error');
            return;
        }
        
        const postsToUpdate = selectedSite.history.filter(p => p.url !== '#');
        
        try {
            const metricsPromises = postsToUpdate.map(p => clarityService.fetchClarityMetrics(selectedSite!.clarityProjectId!, p.url));
            const metricsResults = await Promise.all(metricsPromises);
            
            const updatedHistory = selectedSite.history.map(post => {
                const postIndex = postsToUpdate.findIndex(p => p.id === post.id);
                if (postIndex !== -1 && metricsResults[postIndex]) {
                    return { ...post, clarityMetrics: metricsResults[postIndex] };
                }
                return post;
            });

            handleSiteUpdate('history', updatedHistory);

        } catch (e: any) {
            toast.addToast(`Failed to refresh Clarity data: ${e.message}`, 'error');
        }
    }, [selectedSite, handleSiteUpdate, toast]);

  if (authLoading) {
    return <div className="h-full w-full flex items-center justify-center"><svg className="animate-spin h-10 w-10 text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle><path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg></div>;
  }
  
  if (!currentUser) {
    return <AuthPage onAuthSuccess={handleAuthSuccess} />;
  }

  if (currentUser.isAdmin && !impersonatingUser) {
      return <AdminDashboard currentUser={currentUser} onImpersonate={handleImpersonate} onSignOut={handleSignOut} />;
  }

  if (isOnboarding) {
      return (
          <OnboardingWizard
              currentUser={currentUser}
              onUpdatePlan={handleUpdatePlan}
              onAddNewSite={handleAddNewSite}
              onComplete={() => setIsOnboarding(false)}
              setActiveTab={setActiveTab}
          />
      );
  }

  if (sites.length === 0 || !selectedSite) {
      return (
          <div className="h-full w-full flex items-center justify-center p-4">
              <div className="text-center">
                  <h1 className="text-2xl font-bold text-white">Welcome to {APP_TITLE}</h1>
                  <p className="text-text-secondary mt-2">Create your first site to get started.</p>
                  <button onClick={handleAddNewSite} className="mt-6 btn btn-primary">
                      + Create New Site
                  </button>
              </div>
          </div>
      );
  }
  
  const planDetails: Record<SubscriptionPlan, { title: string; icon: React.FC<any>; colorClasses: string }> = {
    free: {
        title: 'Free',
        icon: UserIcon,
        colorClasses: 'text-gray-400 border-gray-600 bg-gray-800/50 hover:bg-gray-700/60',
    },
    creator: {
        title: 'Creator',
        icon: PenIcon,
        colorClasses: 'text-cyan-300 border-cyan-500/50 bg-cyan-900/40 hover:bg-cyan-900/60',
    },
    pro: {
        title: 'Pro',
        icon: SparklesIcon,
        colorClasses: 'text-purple-300 border-purple-500/50 bg-purple-900/40 hover:bg-purple-900/60',
    },
    agency: {
        title: 'Agency',
        icon: BuildingOffice2Icon,
        colorClasses: 'text-yellow-300 border-yellow-500/50 bg-yellow-900/40 hover:bg-yellow-900/60',
    },
  };
  
  const currentPlanDetails = planDetails[planAccess.plan];
  const PlanIcon = currentPlanDetails.icon;


  return (
    <div className="h-full w-full flex flex-col md:flex-row bg-[#0a0a0f] text-text-primary">
      {isSidebarOpen && (
          <div 
              onClick={() => setIsSidebarOpen(false)} 
              className="fixed inset-0 bg-black/60 z-20 md:hidden"
              aria-hidden="true"
          />
      )}
      {/* --- SIDEBAR --- */}
      <aside className={`group/sidebar absolute md:relative z-30 w-64 md:w-20 lg:w-64 md:hover:w-64 bg-[#0a0a0f] border-r border-border flex-shrink-0 flex flex-col transition-all duration-300 ease-in-out ${isSidebarOpen ? 'translate-x-0' : '-translate-x-full md:translate-x-0'}`}>
        <div className="h-16 flex-shrink-0 flex items-center justify-between px-4 lg:px-6 border-b border-border">
            <div className="flex items-center gap-3">
                <LogoIcon className="h-7 w-7 text-blue-400" />
                <span className="font-bold text-xl text-white md:hidden lg:inline group-hover/sidebar:inline">{APP_TITLE}</span>
            </div>
            <button onClick={() => setIsSidebarOpen(false)} className="p-2 -mr-2 text-gray-500 hover:text-white md:hidden"><XIcon className="h-6 w-6"/></button>
        </div>
        <div className="flex-1 min-h-0 flex flex-col">
            <div className="p-4 border-b border-border">
                <div className="flex items-center gap-2">
                    <select value={selectedSiteId || ''} onChange={(e) => setSelectedSiteId(e.target.value)} className="input-base px-3 py-2 text-sm w-full truncate flex-1">
                        {sites.map(s => <option key={s.id} value={s.id}>{s.name}</option>)}
                    </select>
                    
                    {selectedSite && (
                        <div className="relative group flex-shrink-0">
                            <button
                                onClick={() => setActiveTab('automation')}
                                className="relative w-9 h-9 rounded-lg bg-gray-950/50 border border-gray-700 hover:border-blue-500 hover:bg-gray-800 transition-colors flex items-center justify-center"
                                aria-label="Automation Status"
                            >
                                <div className="relative flex h-4 w-4">
                                    {isAnyAutomationReady && (
                                        <span className={`animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75`}></span>
                                    )}
                                    <span className={`relative inline-flex rounded-full h-full w-full ${automationStatusColor}`}></span>
                                </div>
                            </button>
                            <div className="absolute left-full top-1/2 -translate-y-1/2 ml-3 w-max bg-gray-900 p-3 rounded-lg border border-gray-700 text-sm text-gray-300 shadow-lg opacity-0 invisible group-hover:visible group-hover:opacity-100 transition-all z-40">
                                <h4 className="font-bold text-white mb-2 text-base">Automation Status</h4>
                                <ul className="